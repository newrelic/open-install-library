# Visit our schema definition for additional information on this file format.
# https://github.com/newrelic/open-install-library/blob/main/docs/recipe-spec/recipe-spec.md#schema-definition

name: ebpf-agent-installer
displayName: eBPF Agent
description: New Relic install recipe for the eBPF agent
repository: https://github.com/newrelic/newrelic-ebpf-agent

installTargets:
  - type: host
    os: linux
    platform: "ubuntu"
    platformVersion: "((20|22|24)\\.04)"
  - type: host
    os: linux
    platform: "debian"
    platformVersion: "((11|12)\\.?.*)"

keywords:
  - eBPF
  - Agent
  - Linux
  - Ubuntu
  - Precise
  - Trusty
  - Xenial
  - Bionic
  - Focal
  - Jammy
  - Noble

processMatch: []

preInstall:
  discoveryMode:
    - targeted

install:
  version: "3"
  silent: true

  tasks:
    default:
      cmds:
        - task: assert_pre_req
        - task: check_config_file
        - task: update_apt
        - task: add_gpg_key
        - task: add_nr_source
        - task: update_apt_nr_source
        - task: install_linux_headers
        - task: install_ebpf_agent
        - task: disable_service_for_agent_control

    assert_pre_req:
      status:
        - |
          if [ "${FORCE_INSTALL:-}" = "true" ]; then
            echo "Force install enabled - skipping pre-requisite checks"
            exit 0
          fi
          # If FORCE_INSTALL is not true, we want the task to run normally
          exit 1
      cmds:
        - |
          IS_ROOT_OR_SUDO=$([ ! -z "$SUDO_USER" ] || [ $(whoami) = "root" ] && echo "true" || echo "false") # Assert root or sudo user
          if [ "$IS_ROOT_OR_SUDO" = "false" ]; then
            echo ""
            echo -e "\e[31mERROR:\e[0m This newrelic install must be run under sudo or root" >&2
            echo ""
            exit 3
          fi
        - |
          IS_GREP_INSTALLED=$(which grep | wc -l)
          if [ $IS_GREP_INSTALLED -eq 0 ] ; then
            echo ""
            echo -e "\e[31mERROR:\e[0m grep is required to run the newrelic install. Please install grep and re-run the installation." >&2
            echo ""
            exit 10
          fi
        - |
          IS_OPENSSL_INSTALLED=$(which openssl | wc -l)
          if [ $IS_OPENSSL_INSTALLED -eq 0 ] ; then
            echo ""
            echo -e "\e[31mERROR:\e[0m openssl is required to run the newrelic install. Please install openssl and re-run the installation." >&2
            echo ""
            exit 14
          fi
        - |
          IS_UNAME_INSTALLED=$(which uname | wc -l)
          if [ $IS_UNAME_INSTALLED -eq 0 ] ; then
            echo ""
            echo -e "\e[31mERROR:\e[0m uname is required to run the newrelic install. Please install uname and re-run the installation." >&2
            echo ""
            exit 15
          fi
        - |
          IS_GPG_AGENT_INSTALLED=$(which gpg-agent | wc -l)
          IS_GPG_CONNECT_AGENT_INSTALLED=$(which gpg-connect-agent | wc -l)
          IS_GPG_INSTALLED=$(which gpg | wc -l)
          if [ $IS_GPG_AGENT_INSTALLED -eq 0 ] || [ $IS_GPG_CONNECT_AGENT_INSTALLED -eq 0 ] || [ $IS_GPG_INSTALLED -eq 0 ]; then
            echo ""
            echo -e "\e[31mERROR:\e[0m GnuPG suite is required to run the newrelic install. Please install gnupg suite and re-run the installation." >&2
            echo ""
            exit 15
          fi
        - |
          IS_CURL_INSTALLED=$(which curl | wc -l)
          if [ $IS_CURL_INSTALLED -eq 0 ] ; then
            echo ""
            echo -e "\e[31mERROR:\e[0m curl is required to run the newrelic install. Please install curl and re-run the installation." >&2
            echo ""
            exit 15
          fi
        - |
          # Check kernel version - eBPF agent requires kernel 5.4 or higher
          KERNEL_VERSION=$(uname -r | cut -d'-' -f1)
          KERNEL_MAJOR=$(echo $KERNEL_VERSION | cut -d'.' -f1)
          KERNEL_MINOR=$(echo $KERNEL_VERSION | cut -d'.' -f2)
          
          # Convert to comparable format (e.g., 5.4 becomes 504, 4.19 becomes 419)
          KERNEL_NUM=$((KERNEL_MAJOR * 100 + KERNEL_MINOR))
          REQUIRED_KERNEL_NUM=504  # 5.4
          
          if [ $KERNEL_NUM -lt $REQUIRED_KERNEL_NUM ]; then
            echo ""
            echo -e "\e[31mERROR:\e[0m eBPF agent requires Linux kernel version 5.4 or higher." >&2
            echo -e "Current kernel version: $KERNEL_VERSION" >&2
            echo -e "Please upgrade your kernel to version 5.4 or higher and re-run the installation." >&2
            echo ""
            exit 17
          fi
        - |
          if [[ ! -d "/px" ]]; then
            if ! mkdir -p "/px"; then
              echo ""
              echo -e "\e[31mERROR:\e[0m Failed to create /px directory. Aborting installation."
              echo ""
              exit 16
            fi
          else
            echo "Directory /px already exists. Continuing with installation."
          fi

    check_config_file:
      cmds:
        - |

          CONFIG_FILE="/etc/newrelic-ebpf-agent/newrelic-ebpf-agent.conf"

          # Function to log errors and exit
          log_error_and_exit() {
              echo ""
              echo -e "\033[0;31mERROR:\033[0m $1"
              echo ""
              exit 1
          }

          create_default_config_file(){
          
              echo "Creating default configuration file at $CONFIG_FILE..."
              # Ensure the directory exists
              if [[ ! -d "/etc/newrelic-ebpf-agent/" ]]; then
                echo "Creating directory /etc/newrelic-ebpf-agent/..."
                mkdir -p "/etc/newrelic-ebpf-agent/" || log_error_and_exit "Failed to create directory /etc/newrelic-ebpf-agent/."
              fi

              if [[ "$NEW_RELIC_REGION" == "staging" ]]; then
                NEW_RELIC_OTLP_ENDPOINT="staging-otlp.nr-data.net:443"
              elif [[ "$NEW_RELIC_REGION" == "EU" ]]; then
                NEW_RELIC_OTLP_ENDPOINT="otlp.eu01.nr-data.net:443"
              elif [[ "$NEW_RELIC_REGION" == "US" ]]; then
                NEW_RELIC_OTLP_ENDPOINT="otlp.nr-data.net:443"
              fi       

              # Create the default configuration file
              tee "$CONFIG_FILE" > /dev/null << EOS
          # -- The license key to use.
          NEW_RELIC_LICENSE_KEY="${NEW_RELIC_LICENSE_KEY:-}"
          # -- Unique name for the deployment to identify data posting via eBPF Agent
          DEPLOYMENT_NAME="${DEPLOYMENT_NAME:-}"
          # -- Endpoint to export data to Newrelic
          OTLP_ENDPOINT="${NEW_RELIC_OTLP_ENDPOINT:-}"
          # -- To configure the log level in increasing order of verboseness. [OFF, FATAL, ERROR, WARNING, INFO, DEBUG]
          NEW_RELIC_LOG_LEVEL=INFO
          # -- To configure log file path of eBPF Agent. If logging to this path fails, logs will be directed to stdout.
          NEW_RELIC_LOG_FILE_PATH="${NEW_RELIC_LOG_FILE_PATH:-}"
          # Regular expression pattern to match the specific name(s) of the entity set that you wish to exclude.
          DROP_DATA_FOR_ENTITY=""
          # Vizier server port on which agent receives pxl scripts from the client.
          VIZIER_PORT="12345"
          # -- Enable TLS communication between the eBPF client and agent.
          TLS_ENABLED="true"
          # -- TLS Certificate Option 1: This must be enabled to create a self-signed cert and secret for you.
          TLS_AUTOGENERATE_CERT_ENABLED="true"
          # -- Certificates path.
          TLS_CERT_PATH="/etc/newrelic-ebpf-agent/certs/"
          # TLS Certificate Option 2: Use your own self-signed certificate. TLS_AUTOGENERATE_CERT_ENABLED must be disabled, and TLS_CERT_FILE, TLS_KEY_FILE, and TLS_CA_FILE must be set.
          # -- Path to your own PEM-encoded certificate.
          TLS_CERT_FILE=""
          # -- Path to your own PEM-encoded private key.
          TLS_KEY_FILE=""
          # -- Path to the CA cert.
          TLS_CA_FILE=""
          # -- The primary lever to control RAM use of the eBPF agent. Specified in MiB.
          TABLE_STORE_DATA_LIMIT_MB=250
          # Sets the absolute path of the complete directory where the required linux headers are manually downloaded and placed for the eBPF agent to use. 
          # This is useful under restricted environments where agent is not able to download required linux headers. The required headers are identified by the agent based on the kernel version. 
          # ---- USE ONLY AFTER NEW RELIC SUPPORT RECOMMENDATION ----
          DOWNLOADED_PACKAGED_HEADERS_PATH=""
          # Sets the absolute path of the complete directory where the linux headers are present for the eBPF agent to use. 
          # This is useful where required linux headers could not be installed or path could not be determined.
          # ---- USE ONLY AFTER NEW RELIC SUPPORT RECOMMENDATION ----
          DISTRO_KERNEL_HEADERS_PATH=""
          # Capability to include/exclude port from entity name, default: true. ex: python:frosty_merkle:[80]
          # Set it to false, to exclude ports from entity name, ex: python:frosty_merkle
          INCLUDE_PORT_IN_SERVER_ENTITY_IDENTIFICATION="true"
          # -- Enable APM data reporting. When enabled, the agent collects and reports application performance monitoring data
          APM_DATA_REPORTING="true"
          # -- Enable TCP statistics reporting. When enabled, the agent collects and reports low level tcp metrics and starts network monitoring
          TCP_STATS_REPORTING="true"

          # To toggle the protocols to enable for tracing in the socket_tracer. There is an ability to configure span export if it is enabled.
          # Each protocol has the flexibility to selectively enable the type of data to export.
          # Metrics are sent by default when a protocol is enabled and it supports metrics. Note: AMQP, Kafka, DNS do not report metrics.
          # PROTOCOLS_<protocol-name>_SPANS_SAMPLING_LATENCY represents the sampling latency threshold for the spans to export. [Options: p1, p10, p50, p90, p99].

          # -- To Enable/Disable the metrics, spans, sampling of latency and error rate of HTTP
          PROTOCOLS_HTTP_ENABLED="true"
          PROTOCOLS_HTTP_SPANS_ENABLED="true"
          PROTOCOLS_HTTP_SPANS_SAMPLING_LATENCY="p50"
          # PROTOCOLS_HTTP_SPANS_SAMPLING_ERROR_RATE represents the error rate threshold for an HTTP route where surpassing it would mean the corresponds spans of the route are exported. [Options: 1-100]
          PROTOCOLS_HTTP_SPANS_SAMPLING_ERROR_RATE=""

          # -- To Enable/Disable the metrics, spans, sampling latency rate of MySQL DB
          PROTOCOLS_MYSQL_ENABLED="true"
          PROTOCOLS_MYSQL_SPANS_ENABLED="true"
          PROTOCOLS_MYSQL_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the metrics, spans, sampling latency rate of PostgreSQL DB
          PROTOCOLS_PGSQL_ENABLED="true"
          PROTOCOLS_PGSQL_SPANS_ENABLED="true"
          PROTOCOLS_PGSQL_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the metrics, spans, sampling latency rate of Cassandra DB
          PROTOCOLS_CASS_ENABLED="true"
          PROTOCOLS_CASS_SPANS_ENABLED="true"
          PROTOCOLS_CASS_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the metrics, spans, sampling latency rate of Redis DB
          PROTOCOLS_REDIS_ENABLED="true"
          PROTOCOLS_REDIS_SPANS_ENABLED="true"
          PROTOCOLS_REDIS_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the metrics, spans, sampling latency rate of MongoDB
          PROTOCOLS_MONGODB_ENABLED="true"
          PROTOCOLS_MONGODB_SPANS_ENABLED="true"
          PROTOCOLS_MONGODB_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the spans and sampling latency of Kafka
          PROTOCOLS_KAFKA_SPANS_ENABLED="true"
          PROTOCOLS_KAFKA_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the spans and sampling latency of AMQP
          PROTOCOLS_AMQP_SPANS_ENABLED="true"
          PROTOCOLS_AMQP_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the spans and sampling latency of DNS
          PROTOCOLS_DNS_SPANS_ENABLED="true"
          PROTOCOLS_DNS_SPANS_SAMPLING_LATENCY=""
          EOS

              source "$CONFIG_FILE"
              echo "Default configuration file created successfully at $CONFIG_FILE."

          }

          check_custom_config_file() {
              FILE_PATH="$1"
              if [[ -f "$FILE_PATH" ]]; then
                  echo "Custom configuration file exists at $FILE_PATH. Proceeding with installation."

                  # Ensure the directory exists
                  if [[ ! -d "/etc/newrelic-ebpf-agent/" ]]; then
                      echo "Creating directory /etc/newrelic-ebpf-agent/..."
                      mkdir -p "/etc/newrelic-ebpf-agent/" || log_error_and_exit "Failed to create directory /etc/newrelic-ebpf-agent/."
                  fi

                  if [[ "$(realpath "$FILE_PATH")" == "$(realpath "$CONFIG_FILE")" ]]; then
                    echo "Custom config file and target config file are the same. Skipping symlink creation."
                  else
                    # Create a symbolic link
                    echo "Creating symbolic link from $FILE_PATH to $CONFIG_FILE..."
                    ln -sf "$(realpath "$FILE_PATH")" "$CONFIG_FILE" || log_error_and_exit "Failed to create symbolic link from $(realpath "$FILE_PATH") to $CONFIG_FILE."
                    echo "Symbolic link created successfully."
                  fi

                source "$CONFIG_FILE"
              else
                  log_error_and_exit "Custom configuration file $FILE_PATH does not exist or is not a valid file. Aborting installation."
              fi
          }

          check_and_autogenerate_cert() {

              echo "Checking if TLS certificate autogeneration is enabled..."
              # Check if TLS_AUTOGENERATE_CERT_ENABLED is set to null or empty
              if [[ -z "$TLS_AUTOGENERATE_CERT_ENABLED" ]]; then
                  echo "TLS_AUTOGENERATE_CERT_ENABLED is not set. Defaulting to true."
                  TLS_AUTOGENERATE_CERT_ENABLED="true"
              fi

              # Check if TLS_AUTOGENERATE_CERT_ENABLED is set to True/true
              if [[ "$TLS_AUTOGENERATE_CERT_ENABLED" == "True" || "$TLS_AUTOGENERATE_CERT_ENABLED" == "true" ]]; then
                  generate_tls_cert
              else
                  echo "Autogenerating TLS certificate skipped..."
                  validate_and_copy_tls_files
              fi
          }

          ensure_tls_certs_directory(){
              # Check if TLS_CERT_PATH is null or empty
              if [[ -z "$TLS_CERT_PATH" ]]; then
                  echo "TLS_CERT_PATH is not set or is empty. Placing certs in the directory /etc/newrelic-ebpf-agent/certs/"
                  TLS_CERT_PATH="/etc/newrelic-ebpf-agent/certs/"
              fi

              # Create the directory if it does not exist
              if [[ ! -d "$TLS_CERT_PATH" ]]; then
                  echo "Creating directory for certificates: $TLS_CERT_PATH"
                  mkdir -p "$TLS_CERT_PATH" || log_error_and_exit "Failed to create directory $TLS_CERT_PATH."
              fi
          }

          generate_tls_cert() {

              ensure_tls_certs_directory
              echo "Autogenerating TLS certificates in $TLS_CERT_PATH."

              # Create an OpenSSL configuration file for generating certificates
              tee "$TLS_CERT_PATH/ssl.conf" > /dev/null << EOS
          [ req ]
          default_bits       = 4096
          distinguished_name = req_distinguished_name
          req_extensions     = req_ext

          [ req_distinguished_name ]

          [ req_ext ]
          subjectAltName = @alt_names

          [alt_names]
          DNS.1   = localhost
          EOS

              # Generate a private key for the Certificate Authority (CA)
              openssl genrsa -out "$TLS_CERT_PATH/ca.key" 4096 || log_error_and_exit "Failed to generate CA private key."

              # Create a self-signed certificate for the CA
              openssl req -new -x509 -sha256 -days 730 -key "$TLS_CERT_PATH/ca.key" -out "$TLS_CERT_PATH/ca.crt" -subj "/O=eBPF/CN=localhost" || log_error_and_exit "Failed to generate CA certificate."

              # Generate a private key for the server
              openssl genrsa -out "$TLS_CERT_PATH/tls.key" 4096 || log_error_and_exit "Failed to generate server private key."

              # Create a certificate signing request (CSR) for the server
              openssl req -new -sha256 -key "$TLS_CERT_PATH/tls.key" -out "$TLS_CERT_PATH/server.csr" -config "$TLS_CERT_PATH/ssl.conf" -subj "/O=eBPF/CN=localhost" || log_error_and_exit "Failed to generate server CSR."

              # Sign the server CSR with the CA certificate to create the server certificate
              openssl x509 -req -sha256 -days 730 -in "$TLS_CERT_PATH/server.csr" -CA "$TLS_CERT_PATH/ca.crt" -CAkey "$TLS_CERT_PATH/ca.key" -set_serial 01 \
                  -out "$TLS_CERT_PATH/tls.crt" -extensions req_ext -extfile "$TLS_CERT_PATH/ssl.conf" || log_error_and_exit "Failed to generate server certificate."

              echo "TLS certificates generated successfully in $TLS_CERT_PATH."
          }


          validate_and_copy_tls_files() {
              echo "Validating TLS environment variables..."

              # Check if any of the variables are empty
              if [[ -z "$TLS_CERT_FILE" || -z "$TLS_KEY_FILE" || -z "$TLS_CA_FILE" ]]; then
                  log_error_and_exit "All three environment variables (TLS_CERT_FILE, TLS_KEY_FILE, TLS_CA_FILE) are required if $TLS_AUTOGENERATE_CERT_ENABLED is not set to True/true."
              fi

              # Check if the file paths provided in the variables are valid
              if [[ ! -f "$TLS_CERT_FILE" ]]; then
                  log_error_and_exit "The file path specified in TLS_CERT_FILE ($TLS_CERT_FILE) is invalid, does not exist, or is a directory."
              fi

              if [[ ! -f "$TLS_KEY_FILE" ]]; then
                  log_error_and_exit "The file path specified in TLS_KEY_FILE ($TLS_KEY_FILE) is invalid, does not exist, or is a directory."
              fi

              if [[ ! -f "$TLS_CA_FILE" ]]; then
                  log_error_and_exit "The file path specified in TLS_CA_FILE ($TLS_CA_FILE) is invalid, does not exist, or is a directory."
              fi

              ensure_tls_certs_directory

              # Copy the files to the destination directory
              echo "Copying TLS certificate files to $TLS_CERT_PATH..."
              cp "$TLS_CERT_FILE" "$TLS_CERT_PATH/tls.crt" || log_error_and_exit "Failed to copy TLS_CERT_FILE to $TLS_CERT_PATH/tls.crt."
              cp "$TLS_KEY_FILE" "$TLS_CERT_PATH/tls.key" || log_error_and_exit "Failed to copy TLS_KEY_FILE to $TLS_CERT_PATH/tls.key."
              cp "$TLS_CA_FILE" "$TLS_CERT_PATH/ca.crt" || log_error_and_exit "Failed to copy TLS_CA_FILE to $TLS_CERT_PATH/tls.key."

              echo "TLS certificate files copied successfully."
          }

          # Delete the existing configuration file if it exists. Helpful in case if user runs the installer multiple times.
          if [[ -f "$CONFIG_FILE" ]]; then
            rm -f "$CONFIG_FILE" || log_error_and_exit "Failed to delete existing configuration file at $CONFIG_FILE."
          fi

          # Set default log file path if NEW_RELIC_LOG_FILE_PATH is empty
          if [ -z "${NEW_RELIC_LOG_FILE_PATH:-}" ]; then
            NEW_RELIC_LOG_FILE_PATH="/var/log/newrelic-ebpf-agent"
          fi

          # Check if CONFIG_FILE_PATH is set and not empty
          if [[ -z "$CONFIG_FILE_PATH" ]]; then
            create_default_config_file
          else
            echo "Using custom configuration file path: $CONFIG_FILE_PATH"
            check_custom_config_file $CONFIG_FILE_PATH
          fi

          if [[ -z "$NEW_RELIC_LICENSE_KEY" ]]; then
              log_error_and_exit "NEW_RELIC_LICENSE_KEY is not found in the config file $CONFIG_FILE. Aborting installation."
          fi

          if [[ -z "$DEPLOYMENT_NAME" && "${NEW_RELIC_AGENT_CONTROL:-}" != "true" ]]; then
              log_error_and_exit "DEPLOYMENT_NAME is empty. Aborting installation."
          fi
          echo "Required config is found."   

          echo "Checking if TLS is enabled..."
          # Check for TLS_ENABLED is set to null or empty
          if [[ -z "$TLS_ENABLED" ]]; then
              echo "TLS_ENABLED is not set in the configuration file. Setting it to true by default."
              TLS_ENABLED="true"
          fi

          # Step 5: Check if TLS_ENABLED is set to True/true
          if [[ "$TLS_ENABLED" == "True" || "$TLS_ENABLED" == "true" ]]; then
              check_and_autogenerate_cert
          else
              echo "TLS is disabled. Skipping certificate generation and validation."
          fi
          
          if [[ ! -d "$NEW_RELIC_LOG_FILE_PATH" ]]; then
            echo "Directory $NEW_RELIC_LOG_FILE_PATH does not exist. Attempting to create it..."
            if ! mkdir -p "$NEW_RELIC_LOG_FILE_PATH"; then
              echo -e "\e[31mERROR:\e[0m Failed to create directory $NEW_RELIC_LOG_FILE_PATH. Aborting installation."
              exit 20
            fi
            echo "Directory $NEW_RELIC_LOG_FILE_PATH created successfully."
          fi
          echo "eBPF logs directory: $NEW_RELIC_LOG_FILE_PATH"
    update_apt:
      cmds:
        - |
          # Get latest definitions and skip any failure because of deprecation
          OPTIONS="-o DPkg::Lock::Timeout=60 -o Acquire::Check-Valid-Until=false"
          if [ ! -z "$HTTPS_PROXY" ]; then
            OPTIONS="$OPTIONS -o Acquire::Http::Proxy={{.HTTPS_PROXY}}"
          fi
          apt-get $OPTIONS update -yq
      silent: true
      # apt will return an error if fails to update any of its sources. Ignore these errors and let the "install_infra" task fail.
      ignore_error: true

    add_gpg_key:
      cmds:
        - |
          # Remove the key from the legacy keyring if it exists
          rm -f /etc/apt/trusted.gpg.d/newrelic-ebpf.gpg 2>/dev/null
          rm -f /etc/apt/trusted.gpg 2>/dev/null
          # Add the key to the correct directory
          curl -s https://download.newrelic.com/infrastructure_agent/gpg/newrelic-infra.gpg | gpg --dearmor --batch --yes -o /etc/apt/trusted.gpg.d/newrelic-ebpf.gpg
      silent: true

    add_nr_source:
      cmds:
        - |
          ARCH="amd64"
          IS_ARM=$(uname -m | grep -i 'aarch64' | wc -l)
          if [ $IS_ARM -gt 0 ] ; then
            ARCH="arm64"
          fi
          printf "deb [arch="$ARCH"] https://download.newrelic.com/preview/linux/apt {{.DEBIAN_CODENAME}} main" | tee /etc/apt/sources.list.d/newrelic-ebpf.list > /dev/null
      vars:
        DEBIAN_CODENAME:
          sh: awk -F= '/VERSION_CODENAME/ {print $2}' /etc/os-release
      silent: true

    update_apt_nr_source:
      cmds:
        - |
          # Get latest definitions and skip any failure because of deprecation
          OPTIONS="-o DPkg::Lock::Timeout=60 -o Acquire::Check-Valid-Until=false"
          if [ ! -z "$HTTPS_PROXY" ]; then
            OPTIONS="$OPTIONS -o Acquire::Http::Proxy={{.HTTPS_PROXY}}"
          fi
          apt-get $OPTIONS update -qq -y
      # apt will return an error if fails to update any of its sources. Ignore these errors and let the "install_infra" task fail.
      ignore_error: true

    install_linux_headers:
      cmds:
        - |
          KERNEL_VERSION=$(uname -r)
          echo "Installing linux headers for kernel version: $KERNEL_VERSION"
          if ! apt-get install -yq --no-install-recommends "linux-headers-$KERNEL_VERSION"; then
            echo ""
            echo -e "\e[31mERROR:\e[0m Failed to install linux headers for kernel $KERNEL_VERSION. Please ensure the correct headers are available and try again."
            echo ""
          fi
          echo "Linux headers installed successfully for kernel $KERNEL_VERSION."
      ignore_error: true

    install_ebpf_agent:
      cmds:
        - |
          export DEBIAN_FRONTEND=noninteractive
          CONFIG_FILE="/etc/newrelic-ebpf-agent/newrelic-ebpf-agent.conf"
          OPTIONS="-o DPkg::Lock::Timeout=60"

          create_default_config_file(){
          
              echo "Creating default configuration file at $CONFIG_FILE..."
              # Ensure the directory exists
              if [[ ! -d "/etc/newrelic-ebpf-agent/" ]]; then
                echo "Creating directory /etc/newrelic-ebpf-agent/..."
                mkdir -p "/etc/newrelic-ebpf-agent/" || log_error_and_exit "Failed to create directory /etc/newrelic-ebpf-agent/."
              fi

              if [[ "$NEW_RELIC_REGION" == "staging" ]]; then
                NEW_RELIC_OTLP_ENDPOINT="staging-otlp.nr-data.net:443"
              elif [[ "$NEW_RELIC_REGION" == "EU" ]]; then
                NEW_RELIC_OTLP_ENDPOINT="otlp.eu01.nr-data.net:443"
              elif [[ "$NEW_RELIC_REGION" == "US" ]]; then
                NEW_RELIC_OTLP_ENDPOINT="otlp.nr-data.net:443"
              fi       

              # Create the default configuration file
              tee "$CONFIG_FILE" > /dev/null << EOS
          # -- The license key to use.
          NEW_RELIC_LICENSE_KEY="${NEW_RELIC_LICENSE_KEY:-}"
          # -- Unique name for the deployment to identify data posting via eBPF Agent
          DEPLOYMENT_NAME="${DEPLOYMENT_NAME:-}"
          # -- Endpoint to export data to Newrelic
          OTLP_ENDPOINT="${NEW_RELIC_OTLP_ENDPOINT:-}"
          # -- To configure the log level in increasing order of verboseness. [OFF, FATAL, ERROR, WARNING, INFO, DEBUG]
          NEW_RELIC_LOG_LEVEL=INFO
          # -- To configure log file path of eBPF Agent. If logging to this path fails, logs will be directed to stdout.
          NEW_RELIC_LOG_FILE_PATH="${NEW_RELIC_LOG_FILE_PATH:-}"
          # Regular expression pattern to match the specific name(s) of the entity set that you wish to exclude.
          DROP_DATA_FOR_ENTITY=""
          # Vizier server port on which agent receives pxl scripts from the client.
          VIZIER_PORT="12345"
          # -- Enable TLS communication between the eBPF client and agent.
          TLS_ENABLED="true"
          # -- TLS Certificate Option 1: This must be enabled to create a self-signed cert and secret for you.
          TLS_AUTOGENERATE_CERT_ENABLED="true"
          # -- Certificates path.
          TLS_CERT_PATH="/etc/newrelic-ebpf-agent/certs/"
          # TLS Certificate Option 2: Use your own self-signed certificate. TLS_AUTOGENERATE_CERT_ENABLED must be disabled, and TLS_CERT_FILE, TLS_KEY_FILE, and TLS_CA_FILE must be set.
          # -- Path to your own PEM-encoded certificate.
          TLS_CERT_FILE=""
          # -- Path to your own PEM-encoded private key.
          TLS_KEY_FILE=""
          # -- Path to the CA cert.
          TLS_CA_FILE=""
          # -- The primary lever to control RAM use of the eBPF agent. Specified in MiB.
          TABLE_STORE_DATA_LIMIT_MB=250
          # Sets the absolute path of the complete directory where the required linux headers are manually downloaded and placed for the eBPF agent to use. 
          # This is useful under restricted environments where agent is not able to download required linux headers. The required headers are identified by the agent based on the kernel version. 
          # ---- USE ONLY AFTER NEW RELIC SUPPORT RECOMMENDATION ----
          DOWNLOADED_PACKAGED_HEADERS_PATH=""
          # Sets the absolute path of the complete directory where the linux headers are present for the eBPF agent to use. 
          # This is useful where required linux headers could not be installed or path could not be determined.
          # ---- USE ONLY AFTER NEW RELIC SUPPORT RECOMMENDATION ----
          DISTRO_KERNEL_HEADERS_PATH=""
          # Capability to include/exclude port from entity name, default: true. ex: python:frosty_merkle:[80]
          # Set it to false, to exclude ports from entity name, ex: python:frosty_merkle
          INCLUDE_PORT_IN_SERVER_ENTITY_IDENTIFICATION="true"
          # -- Enable APM data reporting. When enabled, the agent collects and reports application performance monitoring data
          APM_DATA_REPORTING="true"
          # -- Enable TCP statistics reporting. When enabled, the agent collects and reports low level tcp metrics and starts network monitoring
          TCP_STATS_REPORTING="true"

          # To toggle the protocols to enable for tracing in the socket_tracer. There is an ability to configure span export if it is enabled.
          # Each protocol has the flexibility to selectively enable the type of data to export.
          # Metrics are sent by default when a protocol is enabled and it supports metrics. Note: AMQP, Kafka, DNS do not report metrics.
          # PROTOCOLS_<protocol-name>_SPANS_SAMPLING_LATENCY represents the sampling latency threshold for the spans to export. [Options: p1, p10, p50, p90, p99].

          # -- To Enable/Disable the metrics, spans, sampling of latency and error rate of HTTP
          PROTOCOLS_HTTP_ENABLED="true"
          PROTOCOLS_HTTP_SPANS_ENABLED="true"
          PROTOCOLS_HTTP_SPANS_SAMPLING_LATENCY="p50"
          # PROTOCOLS_HTTP_SPANS_SAMPLING_ERROR_RATE represents the error rate threshold for an HTTP route where surpassing it would mean the corresponds spans of the route are exported. [Options: 1-100]
          PROTOCOLS_HTTP_SPANS_SAMPLING_ERROR_RATE=""

          # -- To Enable/Disable the metrics, spans, sampling latency rate of MySQL DB
          PROTOCOLS_MYSQL_ENABLED="true"
          PROTOCOLS_MYSQL_SPANS_ENABLED="true"
          PROTOCOLS_MYSQL_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the metrics, spans, sampling latency rate of PostgreSQL DB
          PROTOCOLS_PGSQL_ENABLED="true"
          PROTOCOLS_PGSQL_SPANS_ENABLED="true"
          PROTOCOLS_PGSQL_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the metrics, spans, sampling latency rate of Cassandra DB
          PROTOCOLS_CASS_ENABLED="true"
          PROTOCOLS_CASS_SPANS_ENABLED="true"
          PROTOCOLS_CASS_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the metrics, spans, sampling latency rate of Redis DB
          PROTOCOLS_REDIS_ENABLED="true"
          PROTOCOLS_REDIS_SPANS_ENABLED="true"
          PROTOCOLS_REDIS_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the metrics, spans, sampling latency rate of MongoDB
          PROTOCOLS_MONGODB_ENABLED="true"
          PROTOCOLS_MONGODB_SPANS_ENABLED="true"
          PROTOCOLS_MONGODB_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the spans and sampling latency of Kafka
          PROTOCOLS_KAFKA_SPANS_ENABLED="true"
          PROTOCOLS_KAFKA_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the spans and sampling latency of AMQP
          PROTOCOLS_AMQP_SPANS_ENABLED="true"
          PROTOCOLS_AMQP_SPANS_SAMPLING_LATENCY=""

          # -- To Enable/Disable the spans and sampling latency of DNS
          PROTOCOLS_DNS_SPANS_ENABLED="true"
          PROTOCOLS_DNS_SPANS_SAMPLING_LATENCY=""
          EOS

              source "$CONFIG_FILE"
              echo "Default configuration file created successfully at $CONFIG_FILE."

          }

          check_custom_config_file() {
              FILE_PATH="$1"
              if [[ -f "$FILE_PATH" ]]; then
                  echo "Custom configuration file exists at $FILE_PATH. Proceeding with installation."

                  # Ensure the directory exists
                  if [[ ! -d "/etc/newrelic-ebpf-agent/" ]]; then
                      echo "Creating directory /etc/newrelic-ebpf-agent/..."
                      mkdir -p "/etc/newrelic-ebpf-agent/" || log_error_and_exit "Failed to create directory /etc/newrelic-ebpf-agent/."
                  fi

                  if [[ "$(realpath "$FILE_PATH")" == "$(realpath "$CONFIG_FILE")" ]]; then
                    echo "Custom config file and target config file are the same. Skipping symlink creation."
                  else
                    # Create a symbolic link
                    echo "Creating symbolic link from $FILE_PATH to $CONFIG_FILE..."
                    ln -sf "$(realpath "$FILE_PATH")" "$CONFIG_FILE" || log_error_and_exit "Failed to create symbolic link from $(realpath "$FILE_PATH") to $CONFIG_FILE."
                    echo "Symbolic link created successfully."
                  fi

                source "$CONFIG_FILE"
              else
                  log_error_and_exit "Custom configuration file $FILE_PATH does not exist or is not a valid file. Aborting installation."
              fi
          }

          check_and_autogenerate_cert() {

              echo "Checking if TLS certificate autogeneration is enabled..."
              # Check if TLS_AUTOGENERATE_CERT_ENABLED is set to null or empty
              if [[ -z "$TLS_AUTOGENERATE_CERT_ENABLED" ]]; then
                  echo "TLS_AUTOGENERATE_CERT_ENABLED is not set. Defaulting to true."
                  TLS_AUTOGENERATE_CERT_ENABLED="true"
              fi

              # Check if TLS_AUTOGENERATE_CERT_ENABLED is set to True/true
              if [[ "$TLS_AUTOGENERATE_CERT_ENABLED" == "True" || "$TLS_AUTOGENERATE_CERT_ENABLED" == "true" ]]; then
                  generate_tls_cert
              else
                  echo "Autogenerating TLS certificate skipped..."
                  validate_and_copy_tls_files
              fi
          }

          ensure_tls_certs_directory(){
              # Check if TLS_CERT_PATH is null or empty
              if [[ -z "$TLS_CERT_PATH" ]]; then
                  echo "TLS_CERT_PATH is not set or is empty. Placing certs in the directory /etc/newrelic-ebpf-agent/certs/"
                  TLS_CERT_PATH="/etc/newrelic-ebpf-agent/certs/"
              fi

              # Create the directory if it does not exist
              if [[ ! -d "$TLS_CERT_PATH" ]]; then
                  echo "Creating directory for certificates: $TLS_CERT_PATH"
                  mkdir -p "$TLS_CERT_PATH" || log_error_and_exit "Failed to create directory $TLS_CERT_PATH."
              fi
          }

          generate_tls_cert() {

              ensure_tls_certs_directory
              echo "Autogenerating TLS certificates in $TLS_CERT_PATH."

              # Create an OpenSSL configuration file for generating certificates
              tee "$TLS_CERT_PATH/ssl.conf" > /dev/null << EOS
          [ req ]
          default_bits       = 4096
          distinguished_name = req_distinguished_name
          req_extensions     = req_ext

          [ req_distinguished_name ]

          [ req_ext ]
          subjectAltName = @alt_names

          [alt_names]
          DNS.1   = localhost
          EOS

              # Generate a private key for the Certificate Authority (CA)
              openssl genrsa -out "$TLS_CERT_PATH/ca.key" 4096 || log_error_and_exit "Failed to generate CA private key."

              # Create a self-signed certificate for the CA
              openssl req -new -x509 -sha256 -days 730 -key "$TLS_CERT_PATH/ca.key" -out "$TLS_CERT_PATH/ca.crt" -subj "/O=eBPF/CN=localhost" || log_error_and_exit "Failed to generate CA certificate."

              # Generate a private key for the server
              openssl genrsa -out "$TLS_CERT_PATH/tls.key" 4096 || log_error_and_exit "Failed to generate server private key."

              # Create a certificate signing request (CSR) for the server
              openssl req -new -sha256 -key "$TLS_CERT_PATH/tls.key" -out "$TLS_CERT_PATH/server.csr" -config "$TLS_CERT_PATH/ssl.conf" -subj "/O=eBPF/CN=localhost" || log_error_and_exit "Failed to generate server CSR."

              # Sign the server CSR with the CA certificate to create the server certificate
              openssl x509 -req -sha256 -days 730 -in "$TLS_CERT_PATH/server.csr" -CA "$TLS_CERT_PATH/ca.crt" -CAkey "$TLS_CERT_PATH/ca.key" -set_serial 01 \
                  -out "$TLS_CERT_PATH/tls.crt" -extensions req_ext -extfile "$TLS_CERT_PATH/ssl.conf" || log_error_and_exit "Failed to generate server certificate."

              echo "TLS certificates generated successfully in $TLS_CERT_PATH."
          }


          validate_and_copy_tls_files() {
              echo "Validating TLS environment variables..."

              # Check if any of the variables are empty
              if [[ -z "$TLS_CERT_FILE" || -z "$TLS_KEY_FILE" || -z "$TLS_CA_FILE" ]]; then
                  log_error_and_exit "All three environment variables (TLS_CERT_FILE, TLS_KEY_FILE, TLS_CA_FILE) are required if $TLS_AUTOGENERATE_CERT_ENABLED is not set to True/true."
              fi

              # Check if the file paths provided in the variables are valid
              if [[ ! -f "$TLS_CERT_FILE" ]]; then
                  log_error_and_exit "The file path specified in TLS_CERT_FILE ($TLS_CERT_FILE) is invalid, does not exist, or is a directory."
              fi

              if [[ ! -f "$TLS_KEY_FILE" ]]; then
                  log_error_and_exit "The file path specified in TLS_KEY_FILE ($TLS_KEY_FILE) is invalid, does not exist, or is a directory."
              fi

              if [[ ! -f "$TLS_CA_FILE" ]]; then
                  log_error_and_exit "The file path specified in TLS_CA_FILE ($TLS_CA_FILE) is invalid, does not exist, or is a directory."
              fi

              ensure_tls_certs_directory

              # Copy the files to the destination directory
              echo "Copying TLS certificate files to $TLS_CERT_PATH..."
              cp "$TLS_CERT_FILE" "$TLS_CERT_PATH/tls.crt" || log_error_and_exit "Failed to copy TLS_CERT_FILE to $TLS_CERT_PATH/tls.crt."
              cp "$TLS_KEY_FILE" "$TLS_CERT_PATH/tls.key" || log_error_and_exit "Failed to copy TLS_KEY_FILE to $TLS_CERT_PATH/tls.key."
              cp "$TLS_CA_FILE" "$TLS_CERT_PATH/ca.crt" || log_error_and_exit "Failed to copy TLS_CA_FILE to $TLS_CERT_PATH/tls.key."

              echo "TLS certificate files copied successfully."
          }

          apt-get $OPTIONS install -yq --no-install-recommends newrelic-ebpf-agent || {
            if [[ ! -f "$CONFIG_FILE" ]]; then

              # Set default log file path if NEW_RELIC_LOG_FILE_PATH is empty
              if [ -z "${NEW_RELIC_LOG_FILE_PATH:-}" ]; then
                NEW_RELIC_LOG_FILE_PATH="/var/log/newrelic-ebpf-agent"
              fi

              # Check if CONFIG_FILE_PATH is set and not empty
              if [[ -z "$CONFIG_FILE_PATH" ]]; then
                create_default_config_file
              else
                check_custom_config_file $CONFIG_FILE_PATH
              fi

              if [[ -z "$TLS_ENABLED" ]]; then
                echo "TLS_ENABLED is not set in the configuration file. Setting it to true by default."
                TLS_ENABLED="true"
              fi

              if [[ "$TLS_ENABLED" == "True" || "$TLS_ENABLED" == "true" ]]; then
                  check_and_autogenerate_cert
              else
                  echo "TLS is disabled. Skipping certificate generation and validation."
              fi

              if [[ ! -d "$NEW_RELIC_LOG_FILE_PATH" ]]; then
                echo "Directory $NEW_RELIC_LOG_FILE_PATH does not exist. Attempting to create it..."
                if ! mkdir -p "$NEW_RELIC_LOG_FILE_PATH"; then
                  echo -e "\e[31mERROR:\e[0m Failed to create directory $NEW_RELIC_LOG_FILE_PATH. Aborting installation."
                  exit 20
                fi
                echo "Directory $NEW_RELIC_LOG_FILE_PATH created successfully."
              fi
              echo "eBPF logs directory: $NEW_RELIC_LOG_FILE_PATH"

              mkdir -p /px;
              sleep 5s;
              systemctl restart newrelic-ebpf-agent.service
              systemctl restart newrelic-ebpf-agent-client.service
            else
              echo "Error: newrelic-ebpf-agent installation failed"
              echo "Attempting to configure the packages again"
              dpkg --configure -a
              # Check if there was an error
              if [ $? -ne 0 ]; then
                echo "Error found while reconfiguring dpkg database"
                # Force-Install the Software
                echo "Attempting to install any missing dependencies or fixes broken packages."
                apt-get $OPTIONS install -f
                if [ $? -ne 0 ]; then 
                  exit 1
                fi
                echo "Installation is successful"
              fi
            fi
          }

      silent: true
    
    # When the eBPF agent is installed alongside Agent Control, the default services are disabled
    # and the binary execution is orchestrated by Agent Control
    disable_service_for_agent_control:
      status:
        - |
          if [ "${NEW_RELIC_AGENT_CONTROL:-}" = "true" ]; then
            echo "eBPF agent services will be controlled by Agent Control - disabling default startup"
            exit 1
          fi
      cmds:
        - |
          sudo systemctl stop newrelic-ebpf-agent-client
          sudo systemctl disable newrelic-ebpf-agent-client
          sudo systemctl stop newrelic-ebpf-agent
          sudo systemctl disable newrelic-ebpf-agent
      ignore_error: true

postInstall:
  info: |2
      ⚙️  The eBPF Agent configuration file can be found in /etc/newrelic-ebpf-agent/newrelic-ebpf-agent.conf
      Edit this file to make changes or configure advanced features for the agent.
