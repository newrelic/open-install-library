name: postgres-open-source-integration
displayName: PostgreSQL Integration
description: New Relic install recipe for default Postgres Open Source on-host integration (via Infra-Agent)
repository: https://github.com/newrelic/nri-postgresql

dependencies:
  - infrastructure-agent-installer

installTargets:
  - type: host
    os: linux
    platform: "debian"
  - type: host
    os: linux
    platform: "ubuntu"

# keyword convention for dealing with search terms that could land someone on this instrumentation project
keywords:
  - Infrastructure
  - Integration
  - postgres

# CLI runs process detection; this is used to filter recipes that are appropriate for matched processes
processMatch:
  - postgres

# Matches partial list of the Log forwarding parameters
logMatch:
  - name: postgresql
    file: /var/log/postgresql/postgresql*.log

# The newrelic-cli will use this integration name to check the config file(s)
# that were setup during the installation to ensure the integration
# runs properly with the defined environment variables
validationIntegration: postgresql

# DEPRECATED
validationNrql: "SELECT count(*) from PostgresqlDatabaseSample FACET entityGuid SINCE 10 minutes ago WHERE reportingAgent = '{{.INFRA_KEY}}'"

successLinkConfig:
  type: EXPLORER

preInstall:
  info: |2
      To capture data from the PostgreSQL integration, we need to create a new PostgreSQL user with specific permissions (READ).
      The installation will create a strong randomly generated password for that new user.
      This installation may prompt for your postgres user password in order to create this new user.
      More information regarding the prerequisites can be found at https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/postgresql-monitoring-integration#comp-req

install:
  version: "3"
  silent: true

  tasks:
    default:
      cmds:
        - task: assert_infra
        - task: assert_pre_req
        - task: update_apt
        - task: input_assert
          vars:
            MAX_RETRIES: 3
            EXIT130: ""
        - task: restart

    assert_infra:
      cmds:
        - |
          IS_INFRA_INSTALLED=$(sudo ps aux | grep newrelic-infra-service | grep -v grep | wc -l)
          if [ $IS_INFRA_INSTALLED -eq 0 ] ; then
            echo "The infrastructure agent is required to install this integration, we recommend going through our guided install path for this pre-requisite which can be found here:  https://docs.newrelic.com/docs/full-stack-observability/observe-everything/get-started/new-relic-guided-install-overview" >&2
            exit 1
          fi

    assert_pre_req:
      cmds:
        - |
          # Map of tool names to the associated error code
          required_tools_and_error_codes="date:41 sha256sum:42 base64:43 head:44 awk:12"
          for tuple in $required_tools_and_error_codes; do
            tool=$(echo ${tuple} |cut -d':' -f1)
            code=$(echo ${tuple} |cut -d':' -f2)
            IS_TOOL_INSTALLED=$(which ${tool} | wc -l)
            if [ "$IS_TOOL_INSTALLED" -eq 0 ]
            then
              echo -e "{{.RED}}This installation requires '${tool}' to be installed.{{.NOCOLOR}}" >> /dev/stderr
              exit ${code}
            fi
          done

    update_apt:
      cmds:
        - |
          # Get latest definitions and skip any failure because of deprecation
          apt-get -o Acquire::Check-Valid-Until=false update -yq
      silent: true
      # apt will return an error if fails to update any of its sources. Ignore these errors and let the "install_infra" task fail.
      ignore_error: true

    input_assert:
      cmds:
        - |
          TRIES=0

          # Check Env Vars
          NEW_RELIC_ASSUME_YES="{{.NEW_RELIC_ASSUME_YES}}"
          NR_CLI_DB_HOSTNAME="{{.NR_CLI_DB_HOSTNAME}}"
          NR_CLI_DB_PORT="{{.NR_CLI_DB_PORT}}"
          NR_CLI_DB_USERNAME="{{.NR_CLI_DB_USERNAME}}"
          NR_CLI_DB_PASSWORD="{{.NR_CLI_DB_PASSWORD}}"
          NR_CLI_DATABASE="{{.NR_CLI_DATABASE}}"
          NR_CLI_DB_VERSION="{{.NR_CLI_DB_VERSION}}"
          NR_CLI_SSL="{{.NR_CLI_SSL}}"
          NR_CLI_CLIENT_CERT_FILE="{{.NR_CLI_CLIENT_CERT_FILE}}"
          NR_CLI_CERT_KEY="{{.NR_CLI_CERT_KEY}}"
          NR_CLI_TRUST_SERVER_CERTIFICATE="{{.NR_CLI_TRUST_SERVER_CERTIFICATE}}"
          NR_CLI_CERT_AUTH_FILE="{{.NR_CLI_CERT_AUTH_FILE}}"
          NR_CLI_SLOW_QUERY="{{.NR_CLI_SLOW_QUERY}}"

          # Set Defaults
          NR_CLI_DB_HOSTNAME=${NR_CLI_DB_HOSTNAME:-'localhost'}
          NR_CLI_DB_PORT=${NR_CLI_DB_PORT:-'5432'}
          NR_CLI_DATABASE=${NR_CLI_DATABASE:-'postgres'}
          NR_CLI_DB_VERSION=${NR_CLI_DB_VERSION:-'12'}
          NR_CLI_SSL=${NR_CLI_SSL:='false'}
          NR_CLI_TRUST_SERVER_CERTIFICATE=${NR_CLI_TRUST_SERVER_CERTIFICATE:-'false'}
          NR_CLI_DB_USERNAME=${NR_CLI_DB_USERNAME:-'newrelic'}
          GEN_PASSWORD=$(echo -n $(date +%s | sha256sum | base64 | head -c 16); echo "oO0$")
          NR_CLI_DB_PASSWORD=${NR_CLI_DB_PASSWORD:-"$GEN_PASSWORD"}

          # Check the Query monitoring status in previous installation
          QUERY_MONITORING_PREVIOUSLY_ENABLED=0
          if [[ -f /etc/newrelic-infra/integrations.d/postgresql-config.yml ]] && grep -qE '^\s*ENABLE_QUERY_MONITORING\s*:\s*true\s*$' /etc/newrelic-infra/integrations.d/postgresql-config.yml; then
            QUERY_MONITORING_PREVIOUSLY_ENABLED=1
          fi

          # Only execute the PostgreSQL version detection when NR_CLI_SLOW_QUERY is true
          if [[ "$NR_CLI_SLOW_QUERY" == "true" ]]; then
            # Check the host's PostgreSQL version
            HOST_PG_VERSION=""
            if command -v psql &> /dev/null; then
              # Get full PostgreSQL version but only keep the major version number (e.g., 16.8 -> 16)
              HOST_PG_VERSION=$(psql --version | awk '{print $3}' | cut -d. -f1 || echo "")
              if [[ -n "$HOST_PG_VERSION" ]]; then
                echo "[INFO] Detected PostgreSQL major version on host: $HOST_PG_VERSION"
                # Only update if not explicitly set by user
                if [[ "$NR_CLI_DB_VERSION" == "12" ]]; then
                  NR_CLI_DB_VERSION="$HOST_PG_VERSION"
                  echo "[INFO] Using detected host PostgreSQL major version: $NR_CLI_DB_VERSION"
                fi
              fi
            fi

            # If psql command not available, try to detect from installed packages
            if [[ -z "$HOST_PG_VERSION" ]]; then
              if command -v dpkg &> /dev/null; then
                INSTALLED_PG=$(dpkg -l | grep postgresql-[0-9] | head -1 | awk '{print $2}' || echo "")
                if [[ -n "$INSTALLED_PG" ]]; then
                  # Extract only the major version number (e.g., postgresql-16.8 -> 16)
                  HOST_PG_VERSION=$(echo "$INSTALLED_PG" | grep -oP '(?<=postgresql-)[0-9]+' || echo "")
                  if [[ -n "$HOST_PG_VERSION" ]]; then
                    echo "[INFO] Detected PostgreSQL major version from installed packages: $HOST_PG_VERSION"
                    # Only update if not explicitly set by user
                    if [[ "$NR_CLI_DB_VERSION" == "12" ]]; then
                      NR_CLI_DB_VERSION="$HOST_PG_VERSION"
                      echo "[INFO] Using detected installed PostgreSQL major version: $NR_CLI_DB_VERSION"
                    fi
                  fi
                fi
              fi
            fi
          else
            echo "[INFO] Skipping additional permission granting as NR_CLI_SLOW_QUERY is not enabled."
          fi

          # Detect PostgreSQL version if not provided or confirm the user's choice
          if [[ "$NEW_RELIC_ASSUME_YES" != "true" ]]; then
            # Instead of trying to detect version by connecting with newrelic user,
            # we'll check if postgres admin credentials were provided earlier and use those
            if [[ -n "$POSTGRES_USERNAME" && -n "$POSTGRES_PASSWORD" ]]; then
              DETECTED_VERSION=$(PGPASSWORD=$POSTGRES_PASSWORD psql -U $POSTGRES_USERNAME -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SHOW server_version;" | awk '{print $1}' | cut -d'.' -f1 || echo "")
              
              if [[ -n "$DETECTED_VERSION" ]]; then
                echo "[INFO] Detected PostgreSQL major version: $DETECTED_VERSION"
                # Automatically use the detected version without prompting - using only major version number
                NR_CLI_DB_VERSION=$DETECTED_VERSION
                echo "[INFO] Using detected PostgreSQL major version: $NR_CLI_DB_VERSION"
              fi
            fi
          fi

          # Add to config debug output
          echo "[INFO] Using PostgreSQL version: $NR_CLI_DB_VERSION" | sudo tee -a {{.NEW_RELIC_CLI_LOG_FILE_PATH}} > /dev/null

          # Check default connect
          CAN_CONNECT=$(curl $NR_CLI_DB_HOSTNAME:$NR_CLI_DB_PORT 2>&1 1>/dev/null -s -S | awk -F'[()]' '{print $2}')
          CAN_CONNECT=${CAN_CONNECT:-0}

          if [[ "$NEW_RELIC_ASSUME_YES" != "true" ]]; then
            while [[ $TRIES -lt {{.MAX_RETRIES}} && "$CAN_CONNECT" == "7" ]]; do
              printf "\nPlease enter the port number for your PostgreSQL instance: "
              read -r NR_CLI_DB_PORT
              ((TRIES++))
              CAN_CONNECT=$(curl $NR_CLI_DB_HOSTNAME:$NR_CLI_DB_PORT 2>&1 1>/dev/null -s -S | awk -F'[()]' '{print $2}')
              CAN_CONNECT=${CAN_CONNECT:-0}

              if [ $CAN_CONNECT == "7" ]; then
                printf "\n\nUnable to connect your PostgreSQL instance using provided port.\n" >&2
                if [ ! $TRIES -lt {{.MAX_RETRIES}} ]; then exit 7; fi
                echo "Please try again"
              fi
            done
          else 
            if [[ "$CAN_CONNECT" == "7" ]]; then 
              printf "\n\nUnable to connect your PostgreSQL instance using provided port.\n" >&2
              exit 7 
            fi
          fi
          
          # Script to insert required default NR user
          sql=$(cat <<EOT
          DO
          \$do\$
          BEGIN
            IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE  rolname = 'newrelic') THEN
              CREATE ROLE newrelic LOGIN PASSWORD '$GEN_PASSWORD';
            END IF;
            ALTER USER newrelic WITH PASSWORD '$GEN_PASSWORD';
            GRANT SELECT ON pg_stat_database TO \"$NR_CLI_DB_USERNAME\";
            GRANT SELECT ON pg_stat_database_conflicts TO \"$NR_CLI_DB_USERNAME\";
            GRANT SELECT ON pg_stat_bgwriter TO \"$NR_CLI_DB_USERNAME\";
          END
          \$do\$;

          EOT
          )

          # if credentials are passed in, try it
          if [ -n "$POSTGRES_USERNAME" ]; then
            sudo PGPASSWORD=$POSTGRES_PASSWORD -u $POSTGRES_USERNAME psql -t -A -c "${sql}" > /dev/null 2>&1 || true
            sudo rm -f .nr_script.sql > /dev/null 2>&1
          elif [ "$NR_CLI_DB_USERNAME" == "newrelic" ] && [ "$NR_CLI_DB_PASSWORD" == "$GEN_PASSWORD" ]; then
            sudo -u postgres psql -t -A -c "${sql}" > /dev/null 2>&1 || true
            sudo rm -f .nr_script.sql > /dev/null 2>&1
          fi

          # Check if we can connect using NR user
          IS_DATABASE_VALID=$(PGPASSWORD=$NR_CLI_DB_PASSWORD psql -U $NR_CLI_DB_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "select version();" 2>&1 | grep -i PostgreSQL | grep -v grep | wc -l)
          IS_DATABASE_VALID=${IS_DATABASE_VALID:-0}

          # If it's automatic install, fail here if unable to connect using defaut/env account
          if [[ "$NEW_RELIC_ASSUME_YES" == "true" ]]; then
            if [[ $IS_DATABASE_VALID -le "0" ]]; then
              echo "Could not create required user $NR_CLI_DB_USERNAME on $NR_CLI_DB_HOSTNAME:$NR_CLI_DB_PORT, database $NR_CLI_DATABASE"
              exit 130
            fi
          fi

          if [[ $IS_DATABASE_VALID -le "0" ]]; then
            TRIES=0
            echo -e "\nPlease provide Postgres credentials to connect"
            # the while statement prompt user for postgresql password if required
            # user will have 3 chances to enter correct password
            while [[ $TRIES -lt {{.MAX_RETRIES}} ]]; do
              ((TRIES++))
              read -r -p "Postgres Username (Default postgres)? " POSTGRES_USERNAME
              POSTGRES_USERNAME=${POSTGRES_USERNAME:-postgres}
              stty -echo  # To securely read password; 'read -s $VAR' showed 'illegal -s option' when tried
              read -r -p "Postgres Password? " POSTGRES_PASSWORD
              stty echo
              echo ""

              sudo PGPASSWORD=$POSTGRES_PASSWORD -u $POSTGRES_USERNAME psql -t -A -c "${sql}" > /dev/null 2>&1 || true
              sudo rm -f .nr_script.sql > /dev/null 2>&1
              IS_DATABASE_VALID=$(PGPASSWORD=$NR_CLI_DB_PASSWORD psql -U $NR_CLI_DB_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "select version();" 2>&1 | grep -i PostgreSQL | grep -v grep | wc -l)
              IS_DATABASE_VALID=${IS_DATABASE_VALID:-0}

              if [[ $IS_DATABASE_VALID -gt "0" ]]; then 
                break
              else
                printf "\n\nUnable to create the required newrelic user.  PostgreSQL account information is required.  Please try again.\n\n" >&3
              fi
            done
          fi

          # if still unable to connect exit out
          if [[ $IS_DATABASE_VALID -eq "0" ]]; then
            exit 130
          fi

          if [ "$NR_CLI_DB_USERNAME" == "" ]; then
            EXIT130=" - NR_CLI_DB_USERNAME=<postgres_username>\n"
          fi
          if [ "$NR_CLI_DB_PASSWORD" == "" ]; then
            EXIT130="$EXIT130 - NR_CLI_DB_PASSWORD=<postgres_password>\n"
          fi

          if [ "$EXIT130" != "" ]; then
            printf "You did not provide all the required environment variables. Please set the following variable(s) and try again:\n\n$EXIT130\n"
            exit 130
          else
            printf "\n[OK] All checks passed. Installing Postgres Integration...\n\n"
          fi

          # Prerequisites
          # Before enabling the extensions, make sure you have the following installed:
          sudo apt update
          sudo apt install -y golang-go gcc make
          
          # Check if slow query monitoring is enabled
          if [[ "$NR_CLI_SLOW_QUERY" == "true" ]]; then
            # Install the PostgreSQL server dev package with proper version
            echo "[INFO] Installing PostgreSQL development package (postgresql-server-dev-$NR_CLI_DB_VERSION)..."
            sudo apt-get install -y postgresql-server-dev-$NR_CLI_DB_VERSION
            
            # Verify the PostgreSQL dev package is properly installed
            if [ ! -f "/usr/include/postgresql/$NR_CLI_DB_VERSION/server/postgres.h" ] && [ ! -f "/usr/include/postgresql/server/postgres.h" ]; then
              echo -e "\033[0;31m[ERROR] PostgreSQL development headers not found. Cannot compile extensions.\033[0m" >&2
              echo -e "\033[0;33m[WARNING] Continuing installation without pg_wait_sampling and pg_stat_monitor extensions.\033[0m" >&2
            else
              # Configure PG_CONFIG if needed
              if [ -f "/usr/lib/postgresql/$NR_CLI_DB_VERSION/bin/pg_config" ]; then
                export PG_CONFIG="/usr/lib/postgresql/$NR_CLI_DB_VERSION/bin/pg_config"
              elif [ -f "/usr/bin/pg_config" ]; then
                export PG_CONFIG="/usr/bin/pg_config"
              fi
              
              # Enable the pg_wait_sampling extension
              echo "[INFO] Cloning and compiling pg_wait_sampling extension..."
              if [ -d "pg_wait_sampling" ]; then
                rm -rf pg_wait_sampling
              fi
              git clone https://github.com/postgrespro/pg_wait_sampling.git
              cd pg_wait_sampling
              
              # If PG_CONFIG was found, use it explicitly
              if [ -n "$PG_CONFIG" ]; then
                sudo make USE_PGXS=1 PG_CONFIG=$PG_CONFIG || echo -e "\033[0;33m[WARNING] Failed to compile pg_wait_sampling, continuing installation.\033[0m" >&2
                sudo make USE_PGXS=1 PG_CONFIG=$PG_CONFIG install || echo -e "\033[0;33m[WARNING] Failed to install pg_wait_sampling, continuing installation.\033[0m" >&2
              else
                sudo make USE_PGXS=1 || echo -e "\033[0;33m[WARNING] Failed to compile pg_wait_sampling, continuing installation.\033[0m" >&2
                sudo make USE_PGXS=1 install || echo -e "\033[0;33m[WARNING] Failed to install pg_wait_sampling, continuing installation.\033[0m" >&2
              fi
              cd ..
              
              # Enable the pg_stat_monitor extension
              echo "[INFO] Cloning and compiling pg_stat_monitor extension..."
              if [ -d "pg_stat_monitor" ]; then
                rm -rf pg_stat_monitor
              fi
              git clone https://github.com/percona/pg_stat_monitor.git
              cd pg_stat_monitor
              
              # If PG_CONFIG was found, use it explicitly
              if [ -n "$PG_CONFIG" ]; then
                sudo make USE_PGXS=1 PG_CONFIG=$PG_CONFIG || echo -e "\033[0;33m[WARNING] Failed to compile pg_stat_monitor, continuing installation.\033[0m" >&2
                sudo make USE_PGXS=1 PG_CONFIG=$PG_CONFIG install || echo -e "\033[0;33m[WARNING] Failed to install pg_stat_monitor, continuing installation.\033[0m" >&2
              else
                sudo make USE_PGXS=1 || echo -e "\033[0;33m[WARNING] Failed to compile pg_stat_monitor, continuing installation.\033[0m" >&2
                sudo make USE_PGXS=1 install || echo -e "\033[0;33m[WARNING] Failed to install pg_stat_monitor, continuing installation.\033[0m" >&2
              fi
              cd ..
            fi
            
            # Find PostgreSQL configuration directory
            echo "[INFO] Looking for PostgreSQL configuration directory..."
            PG_CONFIG_DIR=""
            
            # First try the standard path based on version
            if [ -d "/etc/postgresql/$NR_CLI_DB_VERSION/main" ]; then
              PG_CONFIG_DIR="/etc/postgresql/$NR_CLI_DB_VERSION/main"
            else
              # Search for any PostgreSQL configuration directory
              for dir in /etc/postgresql/*/main; do
                if [ -d "$dir" ]; then
                  PG_CONFIG_DIR="$dir"
                  # Extract the version from the path
                  PG_VERSION_FROM_DIR=$(echo "$dir" | sed -E 's|/etc/postgresql/([^/]+)/main|\1|')
                  echo "[INFO] Found PostgreSQL configuration directory for version $PG_VERSION_FROM_DIR: $dir"
                  # Update NR_CLI_DB_VERSION if it was different
                  if [ "$PG_VERSION_FROM_DIR" != "$NR_CLI_DB_VERSION" ]; then
                    echo "[INFO] Updating detected PostgreSQL version from $NR_CLI_DB_VERSION to $PG_VERSION_FROM_DIR"
                    NR_CLI_DB_VERSION="$PG_VERSION_FROM_DIR"
                  fi
                  break
                fi
              done
            fi
            
            if [ -z "$PG_CONFIG_DIR" ]; then
              echo -e "\033[0;33m[WARNING] Could not find PostgreSQL configuration directory. Some features may not work properly.\033[0m" >&2
            else
              echo "[INFO] Using PostgreSQL configuration directory: $PG_CONFIG_DIR"
            fi
            
            # Define the config file path
            PG_CONFIG_FILE=""
            if [ -n "$PG_CONFIG_DIR" ]; then
              if [ -f "$PG_CONFIG_DIR/postgresql.conf" ]; then
                PG_CONFIG_FILE="$PG_CONFIG_DIR/postgresql.conf"
              elif [ -f "$PG_CONFIG_DIR/postgres.conf" ]; then
                PG_CONFIG_FILE="$PG_CONFIG_DIR/postgres.conf"
              fi
            fi
            
            if [ -z "$PG_CONFIG_FILE" ]; then
              echo -e "\033[0;33m[WARNING] Could not find PostgreSQL configuration file. Some features may not work properly.\033[0m" >&2
            else
              echo "[INFO] Using PostgreSQL configuration file: $PG_CONFIG_FILE"
            fi
  
            # Enable the pg_stat_statement extension
            if [ -n "$PG_CONFIG_FILE" ]; then
              # Create backup of the configuration file
              sudo cp "$PG_CONFIG_FILE" "$PG_CONFIG_FILE.bak"
              echo "[INFO] Created backup of PostgreSQL configuration at $PG_CONFIG_FILE.bak"
              
              # Add extensions to shared_preload_libraries in postgresql.conf
              if grep -q "^#shared_preload_libraries" "$PG_CONFIG_FILE"; then
                sudo sed -i "/^#shared_preload_libraries/c\shared_preload_libraries = 'pg_stat_statements, pg_wait_sampling, pg_stat_monitor'" "$PG_CONFIG_FILE"
                echo "[INFO] Enabled shared_preload_libraries in $PG_CONFIG_FILE"
              elif ! grep -q "shared_preload_libraries" "$PG_CONFIG_FILE"; then
                echo "shared_preload_libraries = 'pg_stat_statements, pg_wait_sampling, pg_stat_monitor'" | sudo tee -a "$PG_CONFIG_FILE" > /dev/null
                echo "[INFO] Added shared_preload_libraries to $PG_CONFIG_FILE"
              else
                echo "[INFO] shared_preload_libraries already configured in $PG_CONFIG_FILE"
              fi
              
              if grep -q "^#pg_stat_statements.max" "$PG_CONFIG_FILE"; then
                sudo sed -i "/^#pg_stat_statements.max/c\pg_stat_statements.max = 10000" "$PG_CONFIG_FILE"
                echo "[INFO] Enabled pg_stat_statements.max in $PG_CONFIG_FILE"
              elif ! grep -q "pg_stat_statements.max" "$PG_CONFIG_FILE"; then
                echo "pg_stat_statements.max = 10000" | sudo tee -a "$PG_CONFIG_FILE" > /dev/null
                echo "[INFO] Added pg_stat_statements.max to $PG_CONFIG_FILE"
              fi
              
              if grep -q "^#pg_stat_statements.track" "$PG_CONFIG_FILE"; then
                sudo sed -i "/^#pg_stat_statements.track/c\pg_stat_statements.track = all" "$PG_CONFIG_FILE"
                echo "[INFO] Enabled pg_stat_statements.track in $PG_CONFIG_FILE"
              elif ! grep -q "pg_stat_statements.track" "$PG_CONFIG_FILE"; then
                echo "pg_stat_statements.track = all" | sudo tee -a "$PG_CONFIG_FILE" > /dev/null
                echo "[INFO] Added pg_stat_statements.track to $PG_CONFIG_FILE"
              fi
              
              if grep -q "^#pg_stat_statements.save" "$PG_CONFIG_FILE"; then
                sudo sed -i "/^#pg_stat_statements.save/c\pg_stat_statements.save = on" "$PG_CONFIG_FILE"
                echo "[INFO] Enabled pg_stat_statements.save in $PG_CONFIG_FILE"
              elif ! grep -q "pg_stat_statements.save" "$PG_CONFIG_FILE"; then
                echo "pg_stat_statements.save = on" | sudo tee -a "$PG_CONFIG_FILE" > /dev/null
                echo "[INFO] Added pg_stat_statements.save to $PG_CONFIG_FILE"
              fi
            else
              echo -e "\033[0;33m[WARNING] Could not find PostgreSQL configuration file to configure statistics extensions. You may need to manually configure these.\033[0m" >&2
            fi
  
            # Offer to restart PostgreSQL if configuration was changed
            if [ -n "$PG_CONFIG_FILE" ]; then
              # Ask to restart PostgreSQL only if we haven't already asked before
              PG_RESTART_DONE="${PG_RESTART_DONE:-false}"
              
              if [[ "$PG_RESTART_DONE" != "true" ]]; then
                printf "\nRestart your PostgreSQL instance to enable the query monitoring settings? (y/n): "
                read -r DB_RESTART
                DB_RESTART=${DB_RESTART:-y}
                
                if [ "$DB_RESTART" = "y" ]; then
                  echo "[INFO] Restarting PostgreSQL..."
                  if systemctl status postgresql >/dev/null 2>&1; then
                    sudo systemctl restart postgresql
                    echo "[INFO] PostgreSQL restarted using systemctl"
                  else
                    sudo service postgresql restart
                    echo "[INFO] PostgreSQL restarted using service command"
                  fi
                  # Mark that we've already restarted
                  PG_RESTART_DONE="true"
                else
                  echo "[INFO] Skipping PostgreSQL restart. Changes will apply after next restart."
                  # Mark that user doesn't want to restart
                  PG_RESTART="n"
                fi
              else
                echo "[INFO] PostgreSQL was already restarted earlier in the installation process."
              fi
            fi
  
            # Connect to PostgreSQL and enable extensions in the database
            echo "[INFO] Trying to enable PostgreSQL extensions in database $NR_CLI_DATABASE..."
            
            # Use postgres admin credentials to create extensions
            echo "Please provide PostgreSQL admin credentials to create extensions"
            printf "PostgreSQL Admin Username? "
            read -r ADMIN_USERNAME            
            stty -echo
            printf "Enter PostgreSQL Admin Password: "
            read -r ADMIN_PASSWORD
            ADMIN_PASSWORD=${ADMIN_PASSWORD:-$POSTGRES_PASSWORD}
            stty echo
            printf "\n"
            
            # Create extensions using admin credentials
            echo "[INFO] Attempting to create PostgreSQL extensions..."
            
            # Function to verify extension status
            verify_extension() {
                local ext_name=$1
                echo "[INFO] Verifying extension: $ext_name"
                
                # Check if extension exists in pg_extension
                local EXT_CHECK=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT extname, extversion, extowner::regrole FROM pg_extension WHERE extname = '$ext_name';" 2>&1)
                local STATUS=$?
                
                if [ $STATUS -eq 0 ] && [ ! -z "$EXT_CHECK" ]; then
                    # Extension exists, get details
                    local VERSION=$(echo "$EXT_CHECK" | cut -d'|' -f2)
                    local OWNER=$(echo "$EXT_CHECK" | cut -d'|' -f3)
                    echo "[SUCCESS] Extension $ext_name is properly installed:"
                    echo "  Version: $VERSION"
                    echo "  Owner: $OWNER"
                    
                    # Verify if it's in shared_preload_libraries
                    local PRELOAD_CHECK=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SHOW shared_preload_libraries;" 2>/dev/null)
                    if [[ "$PRELOAD_CHECK" == *"$ext_name"* ]]; then
                        echo "  Loaded in shared_preload_libraries: Yes"
                    else
                        echo -e "\033[0;33m[WARNING] Extension $ext_name is installed but not found in shared_preload_libraries\033[0m" >&2
                        echo -e "\033[0;33mAdd '$ext_name' to shared_preload_libraries in postgresql.conf and restart PostgreSQL\033[0m" >&2
                    fi
                    
                    # Try to verify if extension is actually functional
                    local IS_FUNCTIONAL=false
                    case "$ext_name" in
                        "pg_stat_statements")
                            if PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_stat_statements LIMIT 1;" >/dev/null 2>&1; then
                                IS_FUNCTIONAL=true
                            fi
                            ;;
                        "pg_wait_sampling")
                            if PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_wait_sampling_current LIMIT 1;" >/dev/null 2>&1; then
                                IS_FUNCTIONAL=true
                            fi
                            ;;
                        "pg_stat_monitor")
                            if PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_stat_monitor LIMIT 1;" >/dev/null 2>&1; then
                                IS_FUNCTIONAL=true
                            fi
                            ;;
                    esac
                    
                    if [ "$IS_FUNCTIONAL" = true ]; then
                        echo "  Extension is functional: Yes"
                    else
                        echo -e "\033[0;33m[WARNING] Extension $ext_name is installed but may not be functional\033[0m" >&2
                        echo -e "\033[0;33mMake sure it's properly configured in postgresql.conf and the database was restarted\033[0m" >&2
                    fi
                else
                    echo -e "\033[0;31m[ERROR] Extension $ext_name is NOT installed in database $NR_CLI_DATABASE\033[0m" >&2
                    echo -e "\033[0;33mTo install it, run:\033[0m" >&2
                    echo -e "\033[0;33m    CREATE EXTENSION $ext_name;\033[0m" >&2
                    return 1
                fi
            }

            # Try to create each extension and verify its status
            echo "[INFO] Checking current extensions in database $NR_CLI_DATABASE..."
            echo "----------------------------------------"
            PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -x -c "SELECT * FROM pg_extension;" 2>&1
            echo "----------------------------------------"

            # Try to create and verify each extension
            for ext in "pg_stat_statements" "pg_wait_sampling" "pg_stat_monitor"; do
                echo "[INFO] Creating extension $ext..."
                EXTENSION_OUTPUT=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "CREATE EXTENSION IF NOT EXISTS $ext;" 2>&1)
                CREATE_STATUS=$?
                
                if [ $CREATE_STATUS -eq 0 ]; then
                    # Verify the extension was actually created and is working
                    verify_extension "$ext"
                    VERIFY_STATUS=$?
                    
                    if [ $VERIFY_STATUS -ne 0 ]; then
                        echo -e "\033[0;31m[ERROR] Failed to verify extension $ext after creation attempt\033[0m" >&2
                    fi
                else
                    echo -e "\033[0;31m[ERROR] Failed to create extension $ext: $EXTENSION_OUTPUT\033[0m" >&2
                fi
                echo ""
            done

            # Final verification of all extensions
            echo "[INFO] Final verification of all extensions..."
            echo "----------------------------------------"
            echo "Current state of all extensions in database $NR_CLI_DATABASE:"
            PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -x -c "SELECT * FROM pg_extension WHERE extname IN ('pg_stat_statements', 'pg_wait_sampling', 'pg_stat_monitor');" 2>&1
            echo "----------------------------------------"

            # Try to provide additional permissions if possible
            echo "[INFO] Trying to grant additional permissions to user $NR_CLI_DB_USERNAME..."
            PERMISSION_OUTPUT=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "GRANT pg_read_all_stats TO $NR_CLI_DB_USERNAME;" 2>&1)
            if [ $? -eq 0 ]; then
              echo "[INFO] Successfully granted pg_read_all_stats to $NR_CLI_DB_USERNAME"
            else
              echo -e "\033[0;33m[WARNING] Could not grant pg_read_all_stats to $NR_CLI_DB_USERNAME: $PERMISSION_OUTPUT\033[0m" >&2
            fi
            
            PERMISSION_OUTPUT=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "GRANT SELECT ON ALL TABLES IN SCHEMA public TO $NR_CLI_DB_USERNAME;" 2>&1)
            if [ $? -eq 0 ]; then
              echo "[INFO] Successfully granted SELECT permissions to $NR_CLI_DB_USERNAME"
            else
              echo -e "\033[0;33m[WARNING] Could not grant table SELECT permissions to $NR_CLI_DB_USERNAME: $PERMISSION_OUTPUT\033[0m" >&2
            fi
          else
            echo "[INFO] Skipping pg_stat_monitor installation to avoid potential compilation errors."
          fi

          # Install the integration
          sudo mkdir -p "/etc/newrelic-infra/integrations.d"
          # Get latest definitions and skip any failure because of deprecation
          sudo apt-get install nri-postgresql -y
          if [ -f /etc/newrelic-infra/integrations.d/postgresql-config.yml ]; then
            sudo rm /etc/newrelic-infra/integrations.d/postgresql-config.yml;
          fi
          sudo touch /etc/newrelic-infra/integrations.d/postgresql-config.yml;

          # Conditionally enable query monitoring
          ENABLE_QUERY_MONITORING=""
          if [[ "$NR_CLI_SLOW_QUERY" == "true" || $QUERY_MONITORING_PREVIOUSLY_ENABLED -eq 1 ]]; then
            ENABLE_QUERY_MONITORING="ENABLE_QUERY_MONITORING: true"
            
            if [[ "$NR_CLI_SLOW_QUERY" == "true" ]]; then
              echo -e "\n--- Setting up PostgreSQL query monitoring"
              
              # Check if pg_stat_statements is loaded
              IS_PG_STAT_STATEMENTS_LOADED=$(PGPASSWORD=$NR_CLI_DB_PASSWORD psql -U $NR_CLI_DB_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_stat_statements LIMIT 1;" 2>/dev/null || echo "0")
              
              # Find PostgreSQL config directory and main configuration file
              if [ -n "$PG_CONFIG_DIR" ] && [ -n "$PG_CONFIG_FILE" ]; then
                echo "[NR_CLI_SLOW_QUERY] Found PostgreSQL configuration file at $PG_CONFIG_FILE"
                
                # Create backup of the original config
                sudo cp "$PG_CONFIG_FILE" "$PG_CONFIG_FILE.bak"
                echo "[NR_CLI_SLOW_QUERY] Created backup at $PG_CONFIG_FILE.bak"
                
                # Check if shared_preload_libraries includes pg_stat_statements
                if grep -q "shared_preload_libraries.*pg_stat_statements" "$PG_CONFIG_FILE"; then
                  echo "[NR_CLI_SLOW_QUERY] pg_stat_statements is already in shared_preload_libraries"
                else
                  # Update shared_preload_libraries to include pg_stat_statements
                  if grep -q "^shared_preload_libraries" "$PG_CONFIG_FILE"; then
                    # Append to existing setting if present but not including pg_stat_statements
                    sudo sed -i "/^shared_preload_libraries/s/=\(.*\)/= \1, 'pg_stat_statements'/" "$PG_CONFIG_FILE"
                  else
                    # Add the setting if not present
                    echo "shared_preload_libraries = 'pg_stat_statements'" | sudo tee -a "$PG_CONFIG_FILE" > /dev/null
                  fi
                  echo "[NR_CLI_SLOW_QUERY] Added pg_stat_statements to shared_preload_libraries"
                fi
                
                # Configure pg_stat_statements settings
                if ! grep -q "^pg_stat_statements.max" "$PG_CONFIG_FILE"; then
                  echo "pg_stat_statements.max = 10000" | sudo tee -a "$PG_CONFIG_FILE" > /dev/null
                  echo "[NR_CLI_SLOW_QUERY] Set pg_stat_statements.max = 10000"
                fi
                
                if ! grep -q "^pg_stat_statements.track" "$PG_CONFIG_FILE"; then
                  echo "pg_stat_statements.track = all" | sudo tee -a "$PG_CONFIG_FILE" > /dev/null
                  echo "[NR_CLI_SLOW_QUERY] Set pg_stat_statements.track = all"
                fi
                
                # Check if we already restarted PostgreSQL earlier
                if [[ "$PG_RESTART_DONE" == "true" ]]; then
                  echo "[INFO] PostgreSQL was already restarted earlier in the installation process."
                  
                  # Check if pg_stat_statements extension exists in the database
                  IS_EXTENSION_EXISTS=$(PGPASSWORD=$NR_CLI_DB_PASSWORD psql -U $NR_CLI_DB_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_extension WHERE extname = 'pg_stat_statements';" 2>/dev/null || echo "0")
                  
                  if [[ "$IS_EXTENSION_EXISTS" == "0" ]]; then
                    # Create the extension in the database
                    echo "[NR_CLI_SLOW_QUERY] Creating pg_stat_statements extension in database $NR_CLI_DATABASE"
                    # Try with both the newrelic user and postgres user
                    PGPASSWORD=$NR_CLI_DB_PASSWORD psql -U $NR_CLI_DB_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "CREATE EXTENSION IF NOT EXISTS pg_stat_statements;" 2>/dev/null || \
                    PGPASSWORD=$POSTGRES_PASSWORD psql -U $POSTGRES_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "CREATE EXTENSION IF NOT EXISTS pg_stat_statements;" 2>/dev/null
                  else
                    echo "[NR_CLI_SLOW_QUERY] pg_stat_statements extension is already installed in database $NR_CLI_DATABASE"
                  fi
                elif [[ "$PG_RESTART" == "n" ]]; then
                  echo -e "\n\033[0;33m[Warning] The query monitoring configuration changes will become active the next time you restart your PostgreSQL server. Without those changes, the New Relic integration will not be able to collect SQL query level details.\033[0m" >&2
                else
                  # We haven't restarted PostgreSQL yet, so do it now
                  printf "\nRestart your PostgreSQL instance to enable the query monitoring settings? (y/n): "
                  read -r DB_RESTART
                  DB_RESTART=${DB_RESTART:-y}
                  
                  if [ "$DB_RESTART" = "y" ]; then
                    # Try different ways to restart PostgreSQL
                    if systemctl status postgresql >/dev/null 2>&1; then
                      sudo systemctl restart postgresql
                      echo "[NR_CLI_SLOW_QUERY] PostgreSQL server restarted to apply changes"
                    else
                      sudo service postgresql restart
                      echo "[NR_CLI_SLOW_QUERY] PostgreSQL server restarted to apply changes"
                    fi
                    
                    # Mark that we've already restarted PostgreSQL
                    PG_RESTART_DONE="true"
                    
                    # Check if pg_stat_statements extension exists in the database
                    sleep 5 # Wait for restart to complete
                    IS_EXTENSION_EXISTS=$(PGPASSWORD=$NR_CLI_DB_PASSWORD psql -U $NR_CLI_DB_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_extension WHERE extname = 'pg_stat_statements';" 2>/dev/null || echo "0")
                    
                    if [[ "$IS_EXTENSION_EXISTS" == "0" ]]; then
                      # Create the extension in the database
                      echo "[NR_CLI_SLOW_QUERY] Creating pg_stat_statements extension in database $NR_CLI_DATABASE"
                      # Try with both the newrelic user and postgres user
                      PGPASSWORD=$NR_CLI_DB_PASSWORD psql -U $NR_CLI_DB_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "CREATE EXTENSION IF NOT EXISTS pg_stat_statements;" 2>/dev/null || \
                      PGPASSWORD=$POSTGRES_PASSWORD psql -U $POSTGRES_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "CREATE EXTENSION IF NOT EXISTS pg_stat_statements;" 2>/dev/null
                    else
                      echo "[NR_CLI_SLOW_QUERY] pg_stat_statements extension is already installed in database $NR_CLI_DATABASE"
                    fi
                  else
                    echo -e "\n\033[0;33m[Warning] The query monitoring configuration changes will become active the next time you restart your PostgreSQL server. Without those changes, the New Relic integration will not be able to collect SQL query level details.\033[0m" >&2
                    # Mark that user doesn't want to restart
                    PG_RESTART="n"
                  fi
                fi
              else
                echo -e "\033[0;33m[Warning] The PostgreSQL configuration file could not be found. The query monitoring settings will need to be configured manually.\033[0m" >&2
              fi
            elif [[ "$QUERY_MONITORING_PREVIOUSLY_ENABLED" -eq 1 ]]; then
              echo -e "\033[0;33m[Warning] Query monitoring was previously enabled. This guided install will keep this setting, but cannot safely turn these off if needed. Please find details of what was enabled in a previous guided install in the log file /root/.newrelic/newrelic-cli.log. These details need to be manually reverted, if so desired.\033[0m" >&2
            fi
          fi

          if [ "$NR_CLI_SSL" == "true" ]; then
            sudo tee -a /etc/newrelic-infra/integrations.d/postgresql-config.yml > /dev/null <<EOT
          integrations:
            - name: nri-postgresql
              env:
                HOSTNAME: $NR_CLI_DB_HOSTNAME
                PORT: $NR_CLI_DB_PORT
                USERNAME: $NR_CLI_DB_USERNAME
                PASSWORD: '$NR_CLI_DB_PASSWORD'
                DATABASE: $NR_CLI_DATABASE
                COLLECTION_LIST: 'ALL'
                ENABLE_QUERY_MONITORING: $ENABLE_QUERY_MONITORING
                COLLECT_DB_LOCK_METRICS: false
                ENABLE_SSL: true
                TRUST_SERVER_CERTIFICATE: $NR_CLI_TRUST_SERVER_CERTIFICATE
                SSL_ROOT_CERT_LOCATION: $NR_CLI_CERT_AUTH_FILE
                SSL_CERT_LOCATION: $NR_CLI_CLIENT_CERT_FILE
                SSL_KEY_LOCATION: $NR_CLI_CERT_KEY
                TIMEOUT: 10
              inventory_source: config/postgresql
              interval: 15s
          EOT
          else
            sudo tee -a /etc/newrelic-infra/integrations.d/postgresql-config.yml > /dev/null <<EOT
          integrations:
            - name: nri-postgresql
              env:
                HOSTNAME: $NR_CLI_DB_HOSTNAME
                PORT: $NR_CLI_DB_PORT
                USERNAME: $NR_CLI_DB_USERNAME
                PASSWORD: '$NR_CLI_DB_PASSWORD'
                DATABASE: $NR_CLI_DATABASE
                COLLECTION_LIST: 'ALL'
                $ENABLE_QUERY_MONITORING
                COLLECT_DB_LOCK_METRICS: false
                ENABLE_SSL: false
                TIMEOUT: 10
              inventory_source: config/postgresql
              interval: 15s
          EOT
          fi

    restart:
      cmds:
        - |
          if [ {{.IS_SYSTEMCTL}} -gt 0 ]; then
            sudo systemctl restart newrelic-infra
          else
            if [ {{.IS_INITCTL}} -gt 0 ]; then
              sudo initctl restart newrelic-infra
            else
              sudo /etc/init.d/newrelic-infra restart
            fi
          fi
      vars:
        IS_SYSTEMCTL:
          sh: command -v systemctl | wc -l
        IS_INITCTL:
          sh: command -v initctl | wc -l

postInstall:
  info: |2
      ⚙️  The PostgreSQL configuration file can be found in /etc/newrelic-infra/integrations.d/postgresql-config.yml
      Edit this file to make changes or configure advanced features for this integration. See the docs for options:
      https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/postgresql-monitoring-integration#config