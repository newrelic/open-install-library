name: postgres-open-source-integration
displayName: PostgreSQL Integration
description: New Relic install recipe for default Postgres Open Source on-host integration (via Infra-Agent)
repository: https://github.com/newrelic/nri-postgresql

dependencies:
  - infrastructure-agent-installer

installTargets:
  - type: host
    os: linux
    platform: "debian"
  - type: host
    os: linux
    platform: "ubuntu"

# keyword convention for dealing with search terms that could land someone on this instrumentation project
keywords:
  - Infrastructure
  - Integration
  - postgres

# CLI runs process detection; this is used to filter recipes that are appropriate for matched processes
processMatch:
  - postgres

# Matches partial list of the Log forwarding parameters
logMatch:
  - name: postgresql
    file: /var/log/postgresql/postgresql*.log

# The newrelic-cli will use this integration name to check the config file(s)
# that were setup during the installation to ensure the integration
# runs properly with the defined environment variables
validationIntegration: postgresql

# DEPRECATED
validationNrql: "SELECT count(*) from PostgresqlDatabaseSample FACET entityGuid SINCE 10 minutes ago WHERE reportingAgent = '{{.INFRA_KEY}}'"

successLinkConfig:
  type: EXPLORER

preInstall:
  info: |2
      To capture data from the PostgreSQL integration, we need to create a new PostgreSQL user with specific permissions (READ).
      The installation will create a strong randomly generated password for that new user.
      This installation may prompt for your postgres user password in order to create this new user.
      More information regarding the prerequisites can be found at https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/postgresql-monitoring-integration#comp-req

install:
  version: "3"
  silent: true

  tasks:
    default:
      cmds:
        - task: assert_infra
        - task: assert_pre_req
        - task: update_apt
        - task: input_assert
          vars:
            MAX_RETRIES: 3
            EXIT130: ""
        - task: restart

    assert_infra:
      cmds:
        - |
          IS_INFRA_INSTALLED=$(sudo ps aux | grep newrelic-infra-service | grep -v grep | wc -l)
          if [ $IS_INFRA_INSTALLED -eq 0 ] ; then
            echo "The infrastructure agent is required to install this integration, we recommend going through our guided install path for this pre-requisite which can be found here:  https://docs.newrelic.com/docs/full-stack-observability/observe-everything/get-started/new-relic-guided-install-overview" >&2
            exit 1
          fi

    assert_pre_req:
      cmds:
        - |
          # Map of tool names to the associated error code
          required_tools_and_error_codes="date:41 sha256sum:42 base64:43 head:44 awk:12"
          for tuple in $required_tools_and_error_codes; do
            tool=$(echo ${tuple} |cut -d':' -f1)
            code=$(echo ${tuple} |cut -d':' -f2)
            IS_TOOL_INSTALLED=$(which ${tool} | wc -l)
            if [ "$IS_TOOL_INSTALLED" -eq 0 ]
            then
              echo -e "{{.RED}}This installation requires '${tool}' to be installed.{{.NOCOLOR}}" >> /dev/stderr
              exit ${code}
            fi
          done

    update_apt:
      cmds:
        - |
          # Get latest definitions and skip any failure because of deprecation
          apt-get -o Acquire::Check-Valid-Until=false update -yq
      silent: true
      # apt will return an error if fails to update any of its sources. Ignore these errors and let the "install_infra" task fail.
      ignore_error: true

    input_assert:
      cmds:
        - |
          TRIES=0

          # Check Env Vars
          NEW_RELIC_ASSUME_YES="{{.NEW_RELIC_ASSUME_YES}}"
          NR_CLI_DB_HOSTNAME="{{.NR_CLI_DB_HOSTNAME}}"
          NR_CLI_DB_PORT="{{.NR_CLI_DB_PORT}}"
          NR_CLI_DB_USERNAME="{{.NR_CLI_DB_USERNAME}}"
          NR_CLI_DB_PASSWORD="{{.NR_CLI_DB_PASSWORD}}"
          NR_CLI_DATABASE="{{.NR_CLI_DATABASE}}"
          NR_CLI_DB_VERSION="{{.NR_CLI_DB_VERSION}}"
          NR_CLI_SSL="{{.NR_CLI_SSL}}"
          NR_CLI_CLIENT_CERT_FILE="{{.NR_CLI_CLIENT_CERT_FILE}}"
          NR_CLI_CERT_KEY="{{.NR_CLI_CERT_KEY}}"
          NR_CLI_TRUST_SERVER_CERTIFICATE="{{.NR_CLI_TRUST_SERVER_CERTIFICATE}}"
          NR_CLI_CERT_AUTH_FILE="{{.NR_CLI_CERT_AUTH_FILE}}"
          NR_CLI_SLOW_QUERY="{{.NR_CLI_SLOW_QUERY}}"
          NR_CLI_RDS_SLOW_QUERY="{{.NR_CLI_RDS_SLOW_QUERY}}"

          # Set Defaults
          NR_CLI_DB_HOSTNAME=${NR_CLI_DB_HOSTNAME:-'localhost'}
          NR_CLI_DB_PORT=${NR_CLI_DB_PORT:-'5432'}
          NR_CLI_DATABASE=${NR_CLI_DATABASE:-'postgres'}
          NR_CLI_DB_VERSION=${NR_CLI_DB_VERSION:-'12'}
          NR_CLI_SSL=${NR_CLI_SSL:='false'}
          NR_CLI_TRUST_SERVER_CERTIFICATE=${NR_CLI_TRUST_SERVER_CERTIFICATE:-'false'}
          NR_CLI_DB_USERNAME=${NR_CLI_DB_USERNAME:-'newrelic'}
          GEN_PASSWORD=$(echo -n $(date +%s | sha256sum | base64 | head -c 16); echo "oO0$")
          NR_CLI_DB_PASSWORD=${NR_CLI_DB_PASSWORD:-"$GEN_PASSWORD"}
          
          # Initialize PostgreSQL admin credentials - these will be set when first requested
          # and reused throughout the script
          POSTGRES_ADMIN_USERNAME=""
          POSTGRES_ADMIN_PASSWORD=""
          
          # Ask for hostname upfront if not in automatic mode and either RDS or slow query is enabled
          if [[ "$NEW_RELIC_ASSUME_YES" != "true" ]]; then
            if [[ "$NR_CLI_RDS_SLOW_QUERY" == "true" ]]; then
              printf "\nPlease enter the hostname for your PostgreSQL RDS instance: "
              read -r ENTERED_HOSTNAME
              if [[ -n "$ENTERED_HOSTNAME" ]]; then
                NR_CLI_DB_HOSTNAME=$ENTERED_HOSTNAME
              fi
              
              # Ensure hostname is provided for RDS
              while [[ -z "$NR_CLI_DB_HOSTNAME" ]]; do
                printf "\nHostname cannot be empty. Please enter the hostname for your PostgreSQL RDS instance: "
                read -r NR_CLI_DB_HOSTNAME
              done
            elif [[ "$NR_CLI_SLOW_QUERY" == "true" ]]; then
              printf "\nPlease enter the hostname for your PostgreSQL instance (Default localhost): "
              read -r ENTERED_HOSTNAME
              if [[ -n "$ENTERED_HOSTNAME" ]]; then
                NR_CLI_DB_HOSTNAME=$ENTERED_HOSTNAME
              fi
            fi
          fi

          # Check the Query monitoring status in previous installation
          QUERY_MONITORING_PREVIOUSLY_ENABLED=0
          if [[ -f /etc/newrelic-infra/integrations.d/postgresql-config.yml ]] && grep -qE '^\s*ENABLE_QUERY_MONITORING\s*:\s*true\s*$' /etc/newrelic-infra/integrations.d/postgresql-config.yml; then
            QUERY_MONITORING_PREVIOUSLY_ENABLED=1
          fi

          # Add to config debug output
          echo "[INFO] Using PostgreSQL version: $NR_CLI_DB_VERSION" | sudo tee -a {{.NEW_RELIC_CLI_LOG_FILE_PATH}} > /dev/null

          if [[ "$NEW_RELIC_ASSUME_YES" != "true" ]]; then
            while [[ $TRIES -lt {{.MAX_RETRIES}} && "$CAN_CONNECT" == "7" ]]; do
              printf "\nPlease enter the port number for your PostgreSQL instance: "
              read -r NR_CLI_DB_PORT
              ((TRIES++))
              CAN_CONNECT=$(curl $NR_CLI_DB_HOSTNAME:$NR_CLI_DB_PORT 2>&1 1>/dev/null -s -S | awk -F'[()]' '{print $2}')
              CAN_CONNECT=${CAN_CONNECT:-0}

              if [ $CAN_CONNECT == "7" ]; then
                printf "\n\nUnable to connect your PostgreSQL instance using provided port.\n" >&2
                if [ ! $TRIES -lt {{.MAX_RETRIES}} ]; then exit 7; fi
                echo "Please try again"
              fi
            done
          else 
            if [[ "$CAN_CONNECT" == "7" ]]; then 
              printf "\n\nUnable to connect your PostgreSQL instance using provided port.\n" >&2
              exit 7 
            fi
          fi
          
          # Script to insert required default NR user
          sql=$(cat <<EOT
          DO
          \$do\$
          BEGIN
            IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE  rolname = 'newrelic') THEN
              CREATE ROLE newrelic LOGIN PASSWORD '$GEN_PASSWORD';
            END IF;
            ALTER USER newrelic WITH PASSWORD '$GEN_PASSWORD';
            GRANT SELECT ON pg_stat_database TO \"$NR_CLI_DB_USERNAME\";
            GRANT SELECT ON pg_stat_database_conflicts TO \"$NR_CLI_DB_USERNAME\";
            GRANT SELECT ON pg_stat_bgwriter TO \"$NR_CLI_DB_USERNAME\";
          END
          \$do\$;

          EOT
          )

          # Helper function to grant admin permissions
          grant_admin_permissions() {
            local username=$1
            local password=$2
            local database=$3
            local hostname=$4
            local port=$5
            
            echo "[INFO] Granting required permissions to admin user $username..."
            
            # Grant pg_read_all_stats role to admin user
            echo "[INFO] Granting pg_read_all_stats role to admin user..."
            PERMISSION_OUTPUT=$(PGPASSWORD=$password psql -U $username -d $database -h $hostname -p $port -c "GRANT pg_read_all_stats TO $NR_CLI_DB_USERNAME;" 2>&1)
            if [ $? -eq 0 ]; then
                echo "[SUCCESS] Successfully granted pg_read_all_stats to $NR_CLI_DB_USERNAME"
            else
                echo -e "\033[0;31m[ERROR] Could not grant pg_read_all_stats to $NR_CLI_DB_USERNAME: $PERMISSION_OUTPUT\033[0m" >&2
            fi
            
            # Grant SELECT on all tables in public schema to admin user
            echo "[INFO] Granting SELECT permissions on public schema to admin user..."
            PERMISSION_OUTPUT=$(PGPASSWORD=$password psql -U $username -d $database -h $hostname -p $port -c "GRANT SELECT ON ALL TABLES IN SCHEMA public TO $NR_CLI_DB_USERNAME;" 2>&1)
            if [ $? -eq 0 ]; then
                echo "[SUCCESS] Successfully granted SELECT permissions to $NR_CLI_DB_USERNAME"
            else
                echo -e "\033[0;31m[ERROR] Could not grant table SELECT permissions to $NR_CLI_DB_USERNAME: $PERMISSION_OUTPUT\033[0m" >&2
            fi
          }

          # if credentials are passed in, try it
          if [ -n "$POSTGRES_USERNAME" ]; then
            PGPASSWORD=$POSTGRES_PASSWORD psql -U $POSTGRES_USERNAME -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -d $NR_CLI_DATABASE -c "${sql}" > /dev/null 2>&1 || true
            sudo rm -f .nr_script.sql > /dev/null 2>&1
            # Store these credentials for later use
            POSTGRES_ADMIN_USERNAME=$POSTGRES_USERNAME
            POSTGRES_ADMIN_PASSWORD=$POSTGRES_PASSWORD
          elif [ "$NR_CLI_DB_USERNAME" == "newrelic" ] && [ "$NR_CLI_DB_PASSWORD" == "$GEN_PASSWORD" ]; then
            sudo -u postgres psql -t -A -c "${sql}" > /dev/null 2>&1 || true
            sudo rm -f .nr_script.sql > /dev/null 2>&1
            # Set default postgres admin credentials
            POSTGRES_ADMIN_USERNAME="postgres"
            # We don't have a password here as we're using sudo
          fi

          # Check if we can connect using NR user
          IS_DATABASE_VALID=$(PGPASSWORD=$NR_CLI_DB_PASSWORD psql -U $NR_CLI_DB_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "select version();" 2>&1 | grep -i PostgreSQL | grep -v grep | wc -l)
          IS_DATABASE_VALID=${IS_DATABASE_VALID:-0}

          # If it's automatic install, fail here if unable to connect using defaut/env account
          if [[ "$NEW_RELIC_ASSUME_YES" == "true" ]]; then
            if [[ $IS_DATABASE_VALID -le "0" ]]; then
              echo "Could not create required user $NR_CLI_DB_USERNAME on $NR_CLI_DB_HOSTNAME:$NR_CLI_DB_PORT, database $NR_CLI_DATABASE"
              exit 130
            fi
          fi

          if [[ $IS_DATABASE_VALID -le "0" ]]; then
            TRIES=0
            echo -e "\nPlease provide Postgres credentials to connect"
            # the while statement prompt user for postgresql password if required
            # user will have 3 chances to enter correct password
            while [[ $TRIES -lt {{.MAX_RETRIES}} ]]; do
              ((TRIES++))
              read -r -p "Postgres Username (Default postgres)? " POSTGRES_USERNAME
              POSTGRES_USERNAME=${POSTGRES_USERNAME:-postgres}
              stty -echo  # To securely read password; 'read -s $VAR' showed 'illegal -s option' when tried
              read -r -p "Postgres Password? " POSTGRES_PASSWORD
              stty echo
              echo ""

              # Debug: Show what command we're about to run
              echo "[DEBUG] Running: PGPASSWORD=*** psql -U $POSTGRES_USERNAME -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -d $NR_CLI_DATABASE -c \"...sql...\""
              
              # Use PGPASSWORD directly with psql instead of using sudo with -u which is incorrect
              PGPASSWORD=$POSTGRES_PASSWORD psql -U $POSTGRES_USERNAME -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -d $NR_CLI_DATABASE -c "${sql}" > /dev/null 2>&1
              SQL_STATUS=$?
              
              if [[ $SQL_STATUS -ne 0 ]]; then
                echo "[DEBUG] Failed to execute SQL to create newrelic user: exit code $SQL_STATUS"
              fi
              
              # Check if we can connect using NR user
              echo "[DEBUG] Testing connection with newrelic user"
              IS_DATABASE_VALID=$(PGPASSWORD=$NR_CLI_DB_PASSWORD psql -U $NR_CLI_DB_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "select version();" 2>&1 | grep -i PostgreSQL | grep -v grep | wc -l)
              IS_DATABASE_VALID=${IS_DATABASE_VALID:-0}

              if [[ $IS_DATABASE_VALID -gt "0" ]]; then 
                echo "[SUCCESS] Successfully created and verified newrelic user"
                # Store credentials for later use in the script
                POSTGRES_ADMIN_USERNAME=$POSTGRES_USERNAME
                POSTGRES_ADMIN_PASSWORD=$POSTGRES_PASSWORD
                break
              else
                printf "\n\nUnable to create the required newrelic user.  PostgreSQL account information is required.  Please try again.\n\n" >&3
              fi
            done
          fi

          # if still unable to connect exit out
          if [[ $IS_DATABASE_VALID -eq "0" ]]; then
            exit 130
          fi

          if [ "$NR_CLI_DB_USERNAME" == "" ]; then
            EXIT130=" - NR_CLI_DB_USERNAME=<postgres_username>\n"
          fi
          if [ "$NR_CLI_DB_PASSWORD" == "" ]; then
            EXIT130="$EXIT130 - NR_CLI_DB_PASSWORD=<postgres_password>\n"
          fi

          if [ "$EXIT130" != "" ]; then
            printf "You did not provide all the required environment variables. Please set the following variable(s) and try again:\n\n$EXIT130\n"
            exit 130
          else
            printf "\n[OK] All checks passed. Installing Postgres Integration...\n\n"
          fi

          # Check if RDS slow query monitoring is enabled
          if [[ "$NR_CLI_RDS_SLOW_QUERY" == "true" ]]; then
            echo "[INFO] Setting up PostgreSQL RDS query monitoring..."
            
            # Ensure hostname is not empty for RDS
            if [[ -z "$NR_CLI_DB_HOSTNAME" ]]; then
              if [[ "$NEW_RELIC_ASSUME_YES" != "true" ]]; then
                printf "\nHostname cannot be empty. Please enter the hostname for your PostgreSQL RDS instance: "
                read -r NR_CLI_DB_HOSTNAME
              else
                echo "Hostname is required for RDS monitoring but was not provided."
                exit 1
              fi
            fi
            
            # Check connection
            CAN_CONNECT=$(curl $NR_CLI_DB_HOSTNAME:$NR_CLI_DB_PORT 2>&1 1>/dev/null -s -S | awk -F'[()]' '{print $2}')
            CAN_CONNECT=${CAN_CONNECT:-0}
            
            if [[ "$CAN_CONNECT" == "7" ]]; then
              echo -e "\033[0;31m[ERROR] Unable to connect to PostgreSQL RDS instance at $NR_CLI_DB_HOSTNAME:$NR_CLI_DB_PORT\033[0m" >&2
              exit 7
            fi
            
            # Connect to PostgreSQL and enable pg_stat_statements extension
            echo "[INFO] Trying to enable pg_stat_statements extension in database $NR_CLI_DATABASE..."
            
            # Use stored postgres admin credentials if available, or prompt if not
            if [[ -n "$POSTGRES_ADMIN_USERNAME" && -n "$POSTGRES_ADMIN_PASSWORD" ]]; then
                echo "Using previously provided PostgreSQL admin credentials"
                ADMIN_USERNAME=$POSTGRES_ADMIN_USERNAME
                ADMIN_PASSWORD=$POSTGRES_ADMIN_PASSWORD
            else
                echo "Please provide PostgreSQL admin credentials to create extension"
                printf "PostgreSQL Admin Username? "
                read -r ADMIN_USERNAME
                stty -echo
                printf "Enter PostgreSQL Admin Password: "
                read -r ADMIN_PASSWORD
                stty echo
                printf "\n"
                
                # Store credentials for reuse
                POSTGRES_ADMIN_USERNAME=$ADMIN_USERNAME
                POSTGRES_ADMIN_PASSWORD=$ADMIN_PASSWORD
            fi
            
            # Function to verify pg_stat_statements extension
            verify_rds_extension() {
                echo "[INFO] Verifying extension: pg_stat_statements"
                
                # Check if extension exists in pg_extension
                local EXT_CHECK=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT extname, extversion, extowner::regrole FROM pg_extension WHERE extname = 'pg_stat_statements';" 2>&1)
                local STATUS=$?
                
                if [ $STATUS -eq 0 ] && [ ! -z "$EXT_CHECK" ]; then
                    # Extension exists, get details
                    local VERSION=$(echo "$EXT_CHECK" | cut -d'|' -f2)
                    local OWNER=$(echo "$EXT_CHECK" | cut -d'|' -f3)
                    echo "[SUCCESS] Extension pg_stat_statements is properly installed:"
                    echo "  Version: $VERSION"
                    echo "  Owner: $OWNER"
                    
                    # Try to verify if extension is functional
                    if PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_stat_statements LIMIT 1;" >/dev/null 2>&1; then
                        echo "  Extension is functional: Yes"
                        
                        # Check RDS parameter group settings
                        echo "[INFO] Verifying RDS parameter settings for pg_stat_statements..."
                        local SETTINGS_VERIFIED=true
                        
                        # Query for pg_stat_statements.max
                        local MAX_SETTING=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SHOW pg_stat_statements.max;" 2>/dev/null || echo "")
                        if [ -z "$MAX_SETTING" ] || [ "$MAX_SETTING" -lt 10000 ]; then
                            echo -e "\033[0;33m[WARNING] RDS parameter pg_stat_statements.max is not set to at least 10000\033[0m" >&2
                            SETTINGS_VERIFIED=false
                        fi
                        
                        # Query for pg_stat_statements.track
                        local TRACK_SETTING=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SHOW pg_stat_statements.track;" 2>/dev/null | tr -d ' ' || echo "")
                        if [ "$TRACK_SETTING" != "all" ]; then
                            echo -e "\033[0;33m[WARNING] RDS parameter pg_stat_statements.track is not set to 'all'\033[0m" >&2
                            SETTINGS_VERIFIED=false
                        fi
                        
                        # Query for pg_stat_statements.save
                        local SAVE_SETTING=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SHOW pg_stat_statements.save;" 2>/dev/null | tr -d ' ' || echo "")
                        if [ "$SAVE_SETTING" != "on" ]; then
                            echo -e "\033[0;33m[WARNING] RDS parameter pg_stat_statements.save is not set to 'on'\033[0m" >&2
                            SETTINGS_VERIFIED=false
                        fi
                        
                        if [ "$SETTINGS_VERIFIED" = false ]; then
                            echo -e "\033[0;33m[IMPORTANT] Please update your RDS parameter group with the following settings:\033[0m" >&2
                            echo -e "\033[0;33m  shared_preload_libraries = 'pg_stat_statements'\033[0m" >&2
                            echo -e "\033[0;33m  pg_stat_statements.max = 10000    # Maximum number of statements tracked\033[0m" >&2
                            echo -e "\033[0;33m  pg_stat_statements.track = all    # Track all statements\033[0m" >&2
                            echo -e "\033[0;33m  pg_stat_statements.save = on      # Save statistics across server restarts\033[0m" >&2
                            echo -e "\033[0;33mAfter updating the parameter group, you will need to reboot your RDS instance.\033[0m" >&2
                        fi
                        
                        return 0
                    else
                        echo -e "\033[0;33m[WARNING] pg_stat_statements is installed but may not be functional\033[0m" >&2
                        echo -e "\033[0;33m[IMPORTANT] Please ensure your RDS parameter group has the following settings:\033[0m" >&2
                        echo -e "\033[0;33m  shared_preload_libraries = 'pg_stat_statements'\033[0m" >&2
                        echo -e "\033[0;33m  pg_stat_statements.max = 10000    # Maximum number of statements tracked\033[0m" >&2
                        echo -e "\033[0;33m  pg_stat_statements.track = all    # Track all statements\033[0m" >&2
                        echo -e "\033[0;33m  pg_stat_statements.save = on      # Save statistics across server restarts\033[0m" >&2
                        echo -e "\033[0;33mAfter updating the parameter group, you will need to reboot your RDS instance.\033[0m" >&2
                        echo -e "\033[0;33m[INFO] Continuing with installation despite incomplete configuration\033[0m" >&2
                        return 0 # Return success so installation continues
                    fi
                else
                    echo -e "\033[0;33m[WARNING] Extension pg_stat_statements is NOT installed in database $NR_CLI_DATABASE\033[0m" >&2
                    echo -e "\033[0;33m[IMPORTANT] Please update your RDS parameter group with the following settings:\033[0m" >&2
                    echo -e "\033[0;33m  shared_preload_libraries = 'pg_stat_statements'\033[0m" >&2
                    echo -e "\033[0;33m  pg_stat_statements.max = 10000    # Maximum number of statements tracked\033[0m" >&2
                    echo -e "\033[0;33m  pg_stat_statements.track = all    # Track all statements\033[0m" >&2
                    echo -e "\033[0;33m  pg_stat_statements.save = on      # Save statistics across server restarts\033[0m" >&2
                    echo -e "\033[0;33mAfter updating the parameter group, you will need to reboot your RDS instance.\033[0m" >&2
                    echo -e "\033[0;33m[INFO] Continuing with installation without pg_stat_statements extension\033[0m" >&2
                    return 0 # Return success so installation continues
                fi
            }

            # Try to create and verify pg_stat_statements extension
            echo "[INFO] Creating pg_stat_statements extension..."
            EXTENSION_OUTPUT=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "CREATE EXTENSION IF NOT EXISTS pg_stat_statements;" 2>&1)
            CREATE_STATUS=$?
            
            if [ $CREATE_STATUS -eq 0 ]; then
                verify_rds_extension
                VERIFY_STATUS=$?
                
                if [ $VERIFY_STATUS -eq 0 ]; then
                    # Try to provide additional permissions to admin user
                    grant_admin_permissions "$ADMIN_USERNAME" "$ADMIN_PASSWORD" "$NR_CLI_DATABASE" "$NR_CLI_DB_HOSTNAME" "$NR_CLI_DB_PORT"
                fi
            fi
          elif [[ "$NR_CLI_SLOW_QUERY" == "true" ]]; then
            echo "[INFO] Setting up PostgreSQL query monitoring..."
            
            # Hostname was already requested at the beginning of the script
            
            # Check connection
            CAN_CONNECT=$(curl $NR_CLI_DB_HOSTNAME:$NR_CLI_DB_PORT 2>&1 1>/dev/null -s -S | awk -F'[()]' '{print $2}')
            CAN_CONNECT=${CAN_CONNECT:-0}
            
            if [[ "$CAN_CONNECT" == "7" ]]; then
              echo -e "\033[0;31m[ERROR] Unable to connect to PostgreSQL instance at $NR_CLI_DB_HOSTNAME:$NR_CLI_DB_PORT\033[0m" >&2
              exit 7
            fi
            
            # Find PostgreSQL configuration directory
            echo "[INFO] Looking for PostgreSQL configuration directory..."
            PG_CONFIG_DIR=""
            
            # First try the standard path based on version
            if [ -d "/etc/postgresql/$NR_CLI_DB_VERSION/main" ]; then
              PG_CONFIG_DIR="/etc/postgresql/$NR_CLI_DB_VERSION/main"
            else
              # Search for any PostgreSQL configuration directory
              for dir in /etc/postgresql/*/main; do
                if [ -d "$dir" ]; then
                  PG_CONFIG_DIR="$dir"
                  # Extract the version from the path
                  PG_VERSION_FROM_DIR=$(echo "$dir" | sed -E 's|/etc/postgresql/([^/]+)/main|\1|')
                  echo "[INFO] Found PostgreSQL configuration directory for version $PG_VERSION_FROM_DIR: $dir"
                                    break
                fi
              done
            fi
            
            if [ -z "$PG_CONFIG_DIR" ]; then
              echo -e "\033[0;31m[ERROR] Could not find PostgreSQL configuration directory.\033[0m" >&2
            exit 1
            fi
            
            # Define the config file path and check if it exists
                PG_CONFIG_FILE="$PG_CONFIG_DIR/postgresql.conf"
              if [ ! -f "$PG_CONFIG_FILE" ]; then
              echo -e "\033[0;31m[ERROR] PostgreSQL configuration file not found at $PG_CONFIG_FILE\033[0m" >&2
              exit 1
            fi
  
            # Connect to PostgreSQL and enable extensions in the database
            echo "[INFO] Trying to enable PostgreSQL extensions in database $NR_CLI_DATABASE..."
            
            # Use stored postgres admin credentials if available, or prompt if not
            if [[ -n "$POSTGRES_ADMIN_USERNAME" && -n "$POSTGRES_ADMIN_PASSWORD" ]]; then
                echo "Using previously provided PostgreSQL admin credentials"
                ADMIN_USERNAME=$POSTGRES_ADMIN_USERNAME
                ADMIN_PASSWORD=$POSTGRES_ADMIN_PASSWORD
            else
                echo "Please provide PostgreSQL admin credentials to create extensions"
                printf "PostgreSQL Admin Username? "
                read -r ADMIN_USERNAME
                stty -echo
                printf "Enter PostgreSQL Admin Password: "
                read -r ADMIN_PASSWORD
                stty echo
                printf "\n"
                
                # Store credentials for reuse
                POSTGRES_ADMIN_USERNAME=$ADMIN_USERNAME
                POSTGRES_ADMIN_PASSWORD=$ADMIN_PASSWORD
            fi
            
            # Create extensions using admin credentials
            echo "[INFO] Attempting to create PostgreSQL extensions..."
            
            # Function to verify extension status
            verify_extension() {
                local ext_name=$1
                echo "[INFO] Verifying extension: $ext_name"
                
                # Check if extension exists in pg_extension
                local EXT_CHECK=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT extname, extversion, extowner::regrole FROM pg_extension WHERE extname = '$ext_name';" 2>&1)
                local STATUS=$?
                
                if [ $STATUS -eq 0 ] && [ ! -z "$EXT_CHECK" ]; then
                    # Extension exists, get details
                    local VERSION=$(echo "$EXT_CHECK" | cut -d'|' -f2)
                    local OWNER=$(echo "$EXT_CHECK" | cut -d'|' -f3)
                    echo "[SUCCESS] Extension $ext_name is properly installed:"
                    echo "  Version: $VERSION"
                    echo "  Owner: $OWNER"
                    
                    # Verify if it's in shared_preload_libraries
                    local PRELOAD_CHECK=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SHOW shared_preload_libraries;" 2>/dev/null | tr -d ' ')
                    local IS_IN_PRELOAD=false
                    if [[ "$PRELOAD_CHECK" == *"$ext_name"* ]]; then
                        echo "  Loaded in shared_preload_libraries: Yes"
                        IS_IN_PRELOAD=true
                    else
                        echo -e "\033[0;33m[WARNING] Extension $ext_name is installed but not found in shared_preload_libraries\033[0m" >&2
                        echo -e "\033[0;33mAdd '$ext_name' to shared_preload_libraries in postgresql.conf and restart PostgreSQL\033[0m" >&2
                    fi
                    
                    # Try to verify if extension is actually functional
                    local IS_FUNCTIONAL=false
                    case "$ext_name" in
                        "pg_stat_statements")
                            if PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_stat_statements LIMIT 1;" >/dev/null 2>&1; then
                                IS_FUNCTIONAL=true
                            fi
                            ;;
                        "pg_wait_sampling")
                            if PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_wait_sampling_current LIMIT 1;" >/dev/null 2>&1; then
                                IS_FUNCTIONAL=true
                            fi
                            ;;
                        "pg_stat_monitor")
                            if PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_stat_monitor LIMIT 1;" >/dev/null 2>&1; then
                                IS_FUNCTIONAL=true
                            fi
                            ;;
                    esac
                    
                    if [ "$IS_FUNCTIONAL" = true ] && [ "$IS_IN_PRELOAD" = true ]; then
                        echo "  Extension is functional: Yes"
                    else
                        echo -e "\033[0;33m[WARNING] Extension $ext_name is installed but may not be fully functional\033[0m" >&2
                        if [ "$IS_IN_PRELOAD" = false ]; then
                            echo -e "\033[0;33m  - Add '$ext_name' to shared_preload_libraries in postgresql.conf\033[0m" >&2
                        fi
                        echo -e "\033[0;33m  - Make sure all settings are properly configured in postgresql.conf\033[0m" >&2
                        echo -e "\033[0;33m  - Restart PostgreSQL after making configuration changes\033[0m" >&2
                        echo -e "\033[0;33m[INFO] Continuing with installation despite configuration issues\033[0m" >&2
                        return 0 # Return success so installation continues
                    fi
                else
                    echo -e "\033[0;33m[WARNING] Extension $ext_name is NOT installed in database $NR_CLI_DATABASE\033[0m" >&2
                    echo -e "\033[0;33mTo install it, run:\033[0m" >&2
                    echo -e "\033[0;33m    CREATE EXTENSION $ext_name;\033[0m" >&2
                    echo -e "\033[0;33m[INFO] Continuing with installation without $ext_name extension\033[0m" >&2
                    return 0 # Return success so installation continues
                fi
            }

            # Check for required shared_preload_libraries configuration
            echo "[INFO] Checking PostgreSQL configuration..."
            
            # Read current shared_preload_libraries setting
            CURRENT_PRELOAD=$(grep "^shared_preload_libraries" "$PG_CONFIG_FILE" | sed "s/.*=\s*'\([^']*\)'.*/\1/" || echo "")
            
            # Check if all required libraries are present
            REQUIRED_LIBRARIES=("pg_stat_statements" "pg_wait_sampling" "pg_stat_monitor")
            MISSING_LIBRARIES=()
            
            for lib in "${REQUIRED_LIBRARIES[@]}"; do
              if [[ ! "$CURRENT_PRELOAD" =~ $lib ]]; then
                MISSING_LIBRARIES+=("$lib")
              else
                if [ "$lib" == "pg_stat_statements" ]; then
                  echo "[NR_CLI_SLOW_QUERY] pg_stat_statements is already in shared_preload_libraries"
                fi
              fi
            done
            
            # Now check for the additional required configuration settings for pg_stat_statements
            MISSING_SETTINGS=()
            
            # Check pg_stat_statements.max
            PG_STAT_MAX=$(grep "^pg_stat_statements.max" "$PG_CONFIG_FILE" | grep -oE '[0-9]+' || echo "0")
            if [ "$PG_STAT_MAX" -lt 10000 ]; then
                MISSING_SETTINGS+=("pg_stat_statements.max")
            fi
            
            # Check pg_stat_statements.track
            if ! grep -q "^pg_stat_statements.track\s*=\s*all" "$PG_CONFIG_FILE"; then
                MISSING_SETTINGS+=("pg_stat_statements.track")
            fi
            
            # Check pg_stat_statements.save
            if ! grep -q "^pg_stat_statements.save\s*=\s*on" "$PG_CONFIG_FILE"; then
                MISSING_SETTINGS+=("pg_stat_statements.save")
            fi
            
            # Build the warning message
            if [ ${#MISSING_LIBRARIES[@]} -gt 0 ] || [ ${#MISSING_SETTINGS[@]} -gt 0 ]; then
              echo -e "\033[0;33m[WARNING] Some recommended PostgreSQL configuration options are missing.\033[0m" >&2
              
              if [ ${#MISSING_LIBRARIES[@]} -gt 0 ]; then
                echo -e "\033[0;33mThe following libraries are not configured: ${MISSING_LIBRARIES[*]}\033[0m" >&2
              fi
              
              if [ ${#MISSING_SETTINGS[@]} -gt 0 ]; then
                echo -e "\033[0;33mThe following settings are missing or incorrect: ${MISSING_SETTINGS[*]}\033[0m" >&2
              fi
              
              echo -e "\033[0;33m[IMPORTANT] For optimal PostgreSQL monitoring, please add the following to $PG_CONFIG_FILE and restart PostgreSQL:\033[0m" >&2
              echo -e "\033[0;33m  shared_preload_libraries = 'pg_stat_statements, pg_wait_sampling, pg_stat_monitor'\033[0m" >&2
              echo -e "\033[0;33m  pg_stat_statements.max = 10000    # Maximum number of statements tracked\033[0m" >&2
              echo -e "\033[0;33m  pg_stat_statements.track = all    # Track all statements\033[0m" >&2
              echo -e "\033[0;33m  pg_stat_statements.save = on      # Save statistics across server restarts\033[0m" >&2
              echo -e "\033[0;33mContinuing with installation, but some monitoring features may be limited until these settings are configured.\033[0m" >&2
            else
              echo "[SUCCESS] All required PostgreSQL configuration settings are present."
            fi

            # Try to create each extension and verify its status
            echo "[INFO] Checking current extensions in database $NR_CLI_DATABASE..."
            echo "----------------------------------------"
            PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -x -c "SELECT * FROM pg_extension;" 2>&1
            echo "----------------------------------------"

            # Try to create and verify each extension
            for ext in "pg_stat_statements" "pg_wait_sampling" "pg_stat_monitor"; do
                echo "[INFO] Creating extension $ext..."
                EXTENSION_OUTPUT=$(PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -c "CREATE EXTENSION IF NOT EXISTS $ext;" 2>&1)
                CREATE_STATUS=$?
                
                if [ $CREATE_STATUS -eq 0 ]; then
                    # Verify the extension was actually created and is working
                    verify_extension "$ext" || true  # Continue even if verification fails
                else
                    echo -e "\033[0;33m[WARNING] Failed to create extension $ext: $EXTENSION_OUTPUT\033[0m" >&2
                    echo -e "\033[0;33m[INFO] Continuing with installation - this extension is recommended but not required\033[0m" >&2
                fi
                echo ""
            done

            # Final verification of all extensions
            echo "[INFO] Final verification of all extensions..."
            echo "----------------------------------------"
            echo "Current state of all extensions in database $NR_CLI_DATABASE:"
            PGPASSWORD=$ADMIN_PASSWORD psql -U $ADMIN_USERNAME -d $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -x -c "SELECT * FROM pg_extension WHERE extname IN ('pg_stat_statements', 'pg_wait_sampling', 'pg_stat_monitor');" 2>&1
            echo "----------------------------------------"

            # Only grant admin permissions
            grant_admin_permissions "$ADMIN_USERNAME" "$ADMIN_PASSWORD" "$NR_CLI_DATABASE" "$NR_CLI_DB_HOSTNAME" "$NR_CLI_DB_PORT"
          fi

          # Install the integration
          sudo mkdir -p "/etc/newrelic-infra/integrations.d"
          # Get latest definitions and skip any failure because of deprecation
          if [ "${NEW_RELIC_FIPS_ENABLED:-false}" = "true" ]; then
            echo "FIPS mode enabled. Installing newrelic-postgresql-fips..."
            sudo apt-get install nri-postgresql-fips -y
          else
            echo "FIPS mode not enabled. Installing newrelic-postgresql..."
            sudo apt-get install nri-postgresql -y
          fi
          if [ -f /etc/newrelic-infra/integrations.d/postgresql-config.yml ]; then
            sudo rm /etc/newrelic-infra/integrations.d/postgresql-config.yml;
          fi
          sudo touch /etc/newrelic-infra/integrations.d/postgresql-config.yml;

          # Conditionally enable query monitoring and set RDS flag
          ENABLE_QUERY_MONITORING=""
          IS_RDS_FLAG="IS_RDS: false"
          
          if [[ "$NR_CLI_RDS_SLOW_QUERY" == "true" ]]; then
            IS_RDS_FLAG="IS_RDS: true"
          fi
          
          if [[ "$NR_CLI_SLOW_QUERY" == "true" || "$NR_CLI_RDS_SLOW_QUERY" == "true" || $QUERY_MONITORING_PREVIOUSLY_ENABLED -eq 1 ]]; then
            ENABLE_QUERY_MONITORING="ENABLE_QUERY_MONITORING: true"
            
            if [[ "$NR_CLI_SLOW_QUERY" == "true" ]]; then
              echo "[INFO] Setting up PostgreSQL query monitoring..."
              
              # Check if pg_stat_statements is loaded
              IS_PG_STAT_STATEMENTS_LOADED=$(PGPASSWORD=$NR_CLI_DB_PASSWORD psql -U $NR_CLI_DB_USERNAME -w $NR_CLI_DATABASE -h $NR_CLI_DB_HOSTNAME -p $NR_CLI_DB_PORT -t -c "SELECT count(*) FROM pg_stat_statements LIMIT 1;" 2>/dev/null || echo "0")
              
              # Find PostgreSQL config directory and main configuration file
              if [ -n "$PG_CONFIG_DIR" ] && [ -n "$PG_CONFIG_FILE" ]; then
                echo "[NR_CLI_SLOW_QUERY] Found PostgreSQL configuration file at $PG_CONFIG_FILE"
                
                # Create backup of the original config
                sudo cp "$PG_CONFIG_FILE" "$PG_CONFIG_FILE.bak"
                echo "[NR_CLI_SLOW_QUERY] Created backup at $PG_CONFIG_FILE.bak"
                
                # Check if shared_preload_libraries includes pg_stat_statements
                # Check if pg_stat_statements is in shared_preload_libraries but don't modify it
                if grep -q "shared_preload_libraries.*pg_stat_statements" "$PG_CONFIG_FILE"; then
                  echo "[NR_CLI_SLOW_QUERY] pg_stat_statements is in shared_preload_libraries"
                else
                  echo -e "\033[0;33m[WARNING] pg_stat_statements should be added to shared_preload_libraries in postgresql.conf manually if needed\033[0m" >&2
                fi
              else
                echo -e "\033[0;33m[Warning] The PostgreSQL configuration file could not be found. The query monitoring settings will need to be configured manually.\033[0m" >&2
              fi
            elif [[ "$QUERY_MONITORING_PREVIOUSLY_ENABLED" -eq 1 ]]; then
              echo -e "\033[0;33m[Warning] Query monitoring was previously enabled. This guided install will keep this setting.\033[0m" >&2
            fi
          fi
          if [ "$NR_CLI_SSL" == "true" ]; then
            sudo tee -a /etc/newrelic-infra/integrations.d/postgresql-config.yml > /dev/null <<EOT
          integrations:
            - name: nri-postgresql
              env:
                HOSTNAME: $NR_CLI_DB_HOSTNAME
                PORT: $NR_CLI_DB_PORT
                USERNAME: $NR_CLI_DB_USERNAME
                PASSWORD: '$NR_CLI_DB_PASSWORD'
                DATABASE: $NR_CLI_DATABASE
                COLLECTION_LIST: 'ALL'
                ENABLE_QUERY_MONITORING: $ENABLE_QUERY_MONITORING
                $IS_RDS_FLAG
                COLLECT_DB_LOCK_METRICS: false
                ENABLE_SSL: true
                TRUST_SERVER_CERTIFICATE: $NR_CLI_TRUST_SERVER_CERTIFICATE
                SSL_ROOT_CERT_LOCATION: $NR_CLI_CERT_AUTH_FILE
                SSL_CERT_LOCATION: $NR_CLI_CLIENT_CERT_FILE
                SSL_KEY_LOCATION: $NR_CLI_CERT_KEY
                TIMEOUT: 10
              inventory_source: config/postgresql
              interval: 15s
          EOT
          else
            sudo tee -a /etc/newrelic-infra/integrations.d/postgresql-config.yml > /dev/null <<EOT
          integrations:
            - name: nri-postgresql
              env:
                HOSTNAME: $NR_CLI_DB_HOSTNAME
                PORT: $NR_CLI_DB_PORT
                USERNAME: $NR_CLI_DB_USERNAME
                PASSWORD: '$NR_CLI_DB_PASSWORD'
                DATABASE: $NR_CLI_DATABASE
                COLLECTION_LIST: 'ALL'
                $ENABLE_QUERY_MONITORING
                $IS_RDS_FLAG
                COLLECT_DB_LOCK_METRICS: false
                ENABLE_SSL: false
                TIMEOUT: 10
              inventory_source: config/postgresql
              interval: 15s
          EOT
          fi

    restart:
      cmds:
        - |
          if [ {{.IS_SYSTEMCTL}} -gt 0 ]; then
            sudo systemctl restart newrelic-infra
          else
            if [ {{.IS_INITCTL}} -gt 0 ]; then
              sudo initctl restart newrelic-infra
            else
              sudo /etc/init.d/newrelic-infra restart
            fi
          fi
      vars:
        IS_SYSTEMCTL:
          sh: command -v systemctl | wc -l
        IS_INITCTL:
          sh: command -v initctl | wc -l

postInstall:
  info: |2
      ⚙️  The PostgreSQL configuration file can be found in /etc/newrelic-infra/integrations.d/postgresql-config.yml
      Edit this file to make changes or configure advanced features for this integration. See the docs for options:
      https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/postgresql-monitoring-integration#config