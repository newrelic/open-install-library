# Visit our schema definition for additional information on this file format.
# https://github.com/newrelic/open-install-library/blob/main/docs/recipe-spec/recipe-spec.md#schema-definition

name: kubernetes-open-source-integration
displayName: Kubernetes Integration
description: New Relic install recipe for the Kubernetes integration
repository: https://github.com/newrelic/nri-kubernetes

installTargets:
  - type: host
    os: linux
  - type: host
    os: darwin

keywords:
  - Infrastructure
  - Agent
  - Kubernetes
  - Pixie
  - K8s
  - OpenShift
  - EKS
  - GKE
  - AKS

processMatch: []

successLinkConfig:
  type: EXPLORER

preInstall:
  info: |2
    The Kubernetes Integration installation will use Helm 3 if available.
    If Helm 3 is not available a manifest will be generated and applied using kubectl.

  requireAtDiscovery: |
    SUDO=$(test ! -z "$SUDO_USER" && echo "sudo -u $SUDO_USER" || echo "")
    KUBECTL=$($SUDO which kubectl 2>/dev/null || echo '/usr/local/bin/kubectl')

    if [[ ! -x $KUBECTL ]]; then
      # Not a host that can manage kubernetes
      echo "Installation Error - not a host that can manage kubernetes"
      exit 10
    fi

    K8S_CONFIG_CONTEXTS=$($SUDO $KUBECTL config get-contexts 2>/dev/null | wc -l | xargs)
    if [[ $K8S_CONFIG_CONTEXTS -lt 2 ]]; then
      # No kubectl contexts
      echo "Installation Error: No kubectl contexts"
      exit 45
    fi

    VERIFY_ACTIVE_CLUSTER=$($SUDO $KUBECTL cluster-info 2>/dev/null | grep 'is running' | wc -l | xargs)
    if [[ $VERIFY_ACTIVE_CLUSTER -eq 0 ]]; then
      # No running clusters detected on host
      echo "Installation Error: No running clusters detected on host"
      exit 45
    fi


install:
  version: "3"
  silent: true

  tasks:
    default:
      cmds:
        - task: install

    install:
      cmds:
        - |
          NEW_RELIC_LICENSE_KEY="{{.NEW_RELIC_LICENSE_KEY}}"
          NEW_RELIC_REGION="{{.NEW_RELIC_REGION}}"

          NR_CLI_CLUSTERNAME="{{.NR_CLI_CLUSTERNAME}}"
          NR_CLI_NAMESPACE="{{.NR_CLI_NAMESPACE}}"
          NR_CLI_KSM="{{.NR_CLI_KSM}}"
          NR_CLI_KUBE_EVENTS="{{.NR_CLI_KUBE_EVENTS}}"
          NR_CLI_LOGGING="{{.NR_CLI_LOGGING}}"
          NR_CLI_LOGGING_LOW_DATA_MODE="{{.NR_CLI_LOGGING_LOW_DATA_MODE}}"


          # Prometheus integrations

          # Legacy Prometheus integration
          NR_CLI_PROMETHEUS="{{.NR_CLI_PROMETHEUS}}"

          # Current Prometheus integration
          NR_CLI_PROMETHEUS_AGENT="{{.NR_CLI_PROMETHEUS_AGENT}}"
          NR_CLI_PROMETHEUS_AGENT_LOW_DATA_MODE="{{.NR_CLI_PROMETHEUS_AGENT_LOW_DATA_MODE}}"
          NR_CLI_PROMETHEUS_CUSTOM_APP_LABELS="{{.NR_CLI_PROMETHEUS_CUSTOM_APP_LABELS}}"
          NR_CLI_CURATED="{{.NR_CLI_CURATED}}"

          NR_CLI_LOW_DATA_MODE="{{.NR_CLI_LOW_DATA_MODE}}"
          NR_CLI_PRIVILEGED="{{.NR_CLI_PRIVILEGED}}"
          NR_CLI_BETA="{{.NR_CLI_BETA}}"

          # Deploys New Relic Pixie integration which
          # registers the New Relic plugin in Pixie in order to send data from Pixie to New Relic
          NR_CLI_NEWRELIC_PIXIE="{{.NR_CLI_NEWRELIC_PIXIE}}"

          # Deploys Pixie to cluster
          NR_CLI_PIXIE="{{.NR_CLI_PIXIE}}"

          # Pixie is already deployed in cluster
          NR_CLI_NEWRELIC_PIXIE_INSTALLED="{{.NR_CLI_NEWRELIC_PIXIE_INSTALLED}}"

          NR_CLI_PIXIE_API_KEY="{{.NR_CLI_PIXIE_API_KEY}}"
          NR_CLI_PIXIE_DEPLOY_KEY="{{.NR_CLI_PIXIE_DEPLOY_KEY}}"
          NR_CLI_PIXIE_ADDRESS="{{.NR_CLI_PIXIE_ADDRESS}}"

          PIXIE_SUPPORTED=true
          OLM_INSTALLED=false

          SUDO=$(test ! -z "$SUDO_USER" && echo "sudo -u $SUDO_USER" || echo "")
          KUBECTL=$($SUDO which kubectl 2>/dev/null || echo '/usr/local/bin/kubectl')

          # Output dir for newrelic-k8s.yml file
          KUBECTL_YAML_DIR=/tmp

          # Check the required tools
          if ! which curl 1>/dev/null 2>&1 ; then
            echo "curl is required to run the newrelic install. Please install curl and re-run the installation." >&2
            echo "{\"Metadata\":{\"UnsupportedReason\":\"curl is not installed\"}}" | tee -a {{.NR_CLI_OUTPUT}}
            exit 131
          fi
          if ! which awk 1>/dev/null 2>&1 ; then
            echo "awk is required to run the newrelic install. Please install awk and re-run the installation." >&2
            echo "{\"Metadata\":{\"UnsupportedReason\":\"awk is not installed\"}}" | tee -a {{.NR_CLI_OUTPUT}}
            exit 131
          fi
          if ! which grep 1>/dev/null 2>&1 ; then
            echo "grep is required to run the newrelic install. Please install grep and re-run the installation." >&2
            echo "{\"Metadata\":{\"UnsupportedReason\":\"grep is not installed\"}}" | tee -a {{.NR_CLI_OUTPUT}}
            exit 131
          fi
          if ! which sed 1>/dev/null 2>&1 ; then
            echo "sed is required to run the newrelic install. Please install sed and re-run the installation." >&2
            echo "{\"Metadata\":{\"UnsupportedReason\":\"sed is not installed\"}}" | tee -a {{.NR_CLI_OUTPUT}}
            exit 131
          fi
          if ! which cut 1>/dev/null 2>&1 ; then
            echo "cut is required to run the newrelic install. Please install cut and re-run the installation." >&2
            echo "{\"Metadata\":{\"UnsupportedReason\":\"cut is not installed\"}}" | tee -a {{.NR_CLI_OUTPUT}}
            exit 131
          fi

          # Check the Kubernetes version
          KUBECTL_VERSION=$($SUDO $KUBECTL version --short 2>&1)
          SHORT_FLAG_ERROR=false

          # Check if $KUBECTL_VERSION contains an error with unknown flag --short
          # run again without --short flag since it was deprecated in kubectl version 1.28
          if echo "$KUBECTL_VERSION" | grep -q "unknown flag: --short"
          then
            SHORT_FLAG_ERROR=true
            KUBECTL_VERSION=$($SUDO $KUBECTL version 2>&1)
          fi

          CLIENT_MAJOR_VERSION=$(echo "${KUBECTL_VERSION}" | grep 'Client Version' | awk -F' v' '{ print $2; }' | awk -F. '{ print $1; }')
          CLIENT_MINOR_VERSION=$(echo "${KUBECTL_VERSION}" | grep 'Client Version' | awk -F' v' '{ print $2; }' | awk -F. '{ print $2; }')
          SERVER_MAJOR_VERSION=$(echo "${KUBECTL_VERSION}" | grep 'Server Version' | awk -F' v' '{ print $2; }' | awk -F. '{ print $1; }')
          SERVER_MINOR_VERSION=$(echo "${KUBECTL_VERSION}" | grep 'Server Version' | awk -F' v' '{ print $2; }' | awk -F. '{ print $2; }')

          if [[ $SERVER_MAJOR_VERSION == "" && $SERVER_MINOR_VERSION == "" ]]; then
            if echo $KUBECTL_VERSION | grep refused >/dev/null; then
              echo "Installation failed. kubectl could not connect to the Kubernetes cluster. Check your kubectl configuration, make sure it can connect to your cluster and re-run this command." >&2
              echo "{\"Metadata\":{\"UnsupportedReason\":\"Kubectl cannot connect to the k8s cluster\", \"K8sClientVersion\":\"$CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\", \"K8sServerVersion\":\"$SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\"}}" | tee -a {{.NR_CLI_OUTPUT}}
              exit 131
            else
              echo "Installation failed. Failed to determine the Kubernetes server version from ${KUBECTL_VERSION}" >&2
              echo "{\"Metadata\":{\"UnsupportedReason\":\"Failed to determine k8s server version\", \"K8sClientVersion\":\"$CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\", \"K8sServerVersion\":\"$SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\"}}" | tee -a {{.NR_CLI_OUTPUT}}
              exit 131
            fi
          fi

          if [[ "$CLIENT_MAJOR_VERSION" -lt 1 ]] || [[ "$CLIENT_MAJOR_VERSION" -eq 1 && "$CLIENT_MINOR_VERSION" -lt 10 ]]; then
            echo "Installation failed. kubectl v1.10 or higher is required, found v${CLIENT_MAJOR_VERSION}.${CLIENT_MINOR_VERSION}" >&2
            echo "{\"Metadata\":{\"UnsupportedReason\":\"Unsupported kubectl version - found $CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\", \"K8sClientVersion\":\"$CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\", \"K8sServerVersion\":\"$SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\"}}" | tee -a {{.NR_CLI_OUTPUT}}
            exit 131
          fi

          if [[ "$SERVER_MAJOR_VERSION" -lt 1 ]] || [[ "$SERVER_MAJOR_VERSION" -eq 1 && "$SERVER_MINOR_VERSION" -lt 24 ]] || [[ "$SERVER_MAJOR_VERSION" -eq 1 && "$SERVER_MINOR_VERSION" -gt 28 ]]; then
            echo "Installation failed. Kubernetes v1.24 to v1.28 is required, found v${SERVER_MAJOR_VERSION}.${SERVER_MINOR_VERSION}" >&2
            echo "{\"Metadata\":{\"UnsupportedReason\":\"Unsupported k8s version - found $SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\", \"K8sClientVersion\":\"$CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\", \"K8sServerVersion\":\"$SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\"}}" | tee -a {{.NR_CLI_OUTPUT}}
            exit 131
          fi

          # Due to nr cli limitation, we can only send the last echo message to backend.
          # DEBUG_MESSAGE is used to collect all necessary debug info we need.
          DEBUG_MESSAGE=""

          # Determine if user is installing in gke autopilot

          GKE_AUTOPILOT_ANSWER="N"
          while :; do
            echo -e -n "${GREEN}Are you installing in a GKE Autopilot cluster? Y/N? ${NC} "

            if [[ "{{.NEW_RELIC_ASSUME_YES}}" == "true" ]]; then
              echo "Assume yes flag was provided - answering N for installing in GKE Autopilot."
              echo "Continuing with installing the integration."
              GKE_AUTOPILOT_ANSWER="N"
              break
            else
              read ans
              echo ""
              GKE_AUTOPILOT_ANSWER=$(echo "${ans^^}" | cut -c1-1)
              if [[ "$GKE_AUTOPILOT_ANSWER" == "N" ]]; then
                echo "Continuing with installing the integration."
                echo "{\"Metadata\":{\"gkeAutopilotAnswer\":\"No\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}} > /dev/null
                break
              fi
              if [[ "$GKE_AUTOPILOT_ANSWER" == "Y" ]]; then
                echo "{\"Metadata\":{\"gkeAutopilotAnswer\":\"Yes\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}} > /dev/null
                echo -e "\033[0;31mGKE Autopilot does not allow privileged access. Turning off privileged mode.\033[0m" >&2
                echo -e "\033[0;31mTurning off Pixie for this installation which requires privileged access.\033[0m" >&2
                echo -e "\033[0;31mTurning off Logging for this installation which currently is not supported in GKE Autopilot.\033[0m" >&2
                NR_CLI_PRIVILEGED=false
                PIXIE_SUPPORTED=false

                while :; do
                  echo -e "\033[0;31mUsing FileStore will give better reliability but will imply storage cost on Google Cloud FileStore.\033[0m" >&2
                  echo -e "\033[0;31mNot using FileStore will imply some logs being lost or duplicated during Fluent-Bit redeploys or restarts.\033[0m" >&2
                  echo -e -n "${GREEN}Do you want to use FileStore to keep track of read and sent logs by Fluent-Bit? Y/N? ${NC} "
                  read filestoreans
                  echo ""
                  LOGGING_USE_FILESTORE=$(echo "${filestoreans^^}" | cut -c1-1)
                  if [[ "$LOGGING_USE_FILESTORE" == "Y" ]]; then
                    NR_CLI_LOGGING_PERSISTENCE=persistentVolume
                    NR_CLI_LOGGING_PERSISTENCE_STORAGE_CLASS=standard-rwx
                    NR_CLI_LOGGING_LINUX_MOUNT_PATH=/var/log
                    break
                  fi 
                  if [[ "$LOGGING_USE_FILESTORE" == "N" ]]; then
                    NR_CLI_LOGGING_PERSISTENCE=none
                    break
                  fi
                  echo -e "Please type Y or N only."
                done
                break
              fi
            fi
              echo -e "Please type Y or N only."
          done

          # Determine the cluster name if not provided
          CLUSTER=$($SUDO $KUBECTL config current-context 2>/dev/null || echo "unknown")

          if [[ "$NR_CLI_CLUSTERNAME" == "" && "{{.NEW_RELIC_ASSUME_YES}}" != "true" ]]; then
            while :; do
              echo -e -n "Do you want to install the Kubernetes integration on cluster \033[1m${CLUSTER}\033[0m Y/N (default: Y)? "
              read answer
              echo ""
              NEW_RELIC_CONTINUE=$(echo "${answer^^}" | cut -c1-1)
              if [[ -z "$NEW_RELIC_CONTINUE" ]]; then
                NEW_RELIC_CONTINUE="Y"
              fi
              if [[ "$NEW_RELIC_CONTINUE" == "N" ]]; then
                echo "Exiting the installation"
                exit 130
              fi
              if [[ "$NEW_RELIC_CONTINUE" == "Y" ]]; then
                break
              fi
              echo -e "Please type Y or N only."
            done
          fi

          if [[ "$NR_CLI_CLUSTERNAME" == "" ]]; then
            NR_CLI_CLUSTERNAME="$CLUSTER"
            echo -e "Cluster name set to \033[1m${NR_CLI_CLUSTERNAME}\033[0m" >&2
          fi

          # Set default values for variables
          NR_CLI_NAMESPACE=${NR_CLI_NAMESPACE:-newrelic}
          NR_CLI_KSM=${NR_CLI_KSM:-true}
          NR_CLI_KUBE_EVENTS=${NR_CLI_KUBE_EVENTS:-true}
          NR_CLI_LOGGING=${NR_CLI_LOGGING:-false}
          NR_CLI_LOGGING_LOW_DATA_MODE=${NR_CLI_LOGGING_LOW_DATA_MODE:-true}
          NR_CLI_LOGGING_PERSISTENCE=${NR_CLI_LOGGING_PERSISTENCE:-""}
          NR_CLI_LOGGING_PERSISTENCE_STORAGE_CLASS=${NR_CLI_LOGGING_PERSISTENCE_STORAGE_CLASS:-""}
          NR_CLI_LOGGING_LINUX_MOUNT_PATH=${NR_CLI_LOGGING_LINUX_MOUNT_PATH:-""}

          # Prometheus integrations

          # Legacy Prometheus integration
          NR_CLI_PROMETHEUS=${NR_CLI_PROMETHEUS:-false}

          # Current Prometheus integration
          NR_CLI_PROMETHEUS_AGENT=${NR_CLI_PROMETHEUS_AGENT:-false}
          NR_CLI_PROMETHEUS_AGENT_LOW_DATA_MODE=${NR_CLI_PROMETHEUS_AGENT_LOW_DATA_MODE:-true}
          NR_CLI_CURATED=${NR_CLI_CURATED:-true}

          NR_CLI_LOW_DATA_MODE=${NR_CLI_LOW_DATA_MODE:-true}
          NR_CLI_PRIVILEGED=${NR_CLI_PRIVILEGED:-true}
          NR_CLI_BETA="${NR_CLI_BETA:-false}"

          # Check the Linux kernel version for compatibility if Pixie is set to be installed on cluster
          if [[ "$NR_CLI_PIXIE" == "true" ]]; then
            KERNEL_VERSION=$($SUDO $KUBECTL get nodes -o jsonpath='{.items[0].status.nodeInfo.kernelVersion}')
            KERNEL_MAJOR_VERSION=$(echo "${KERNEL_VERSION}" | awk -F. '{ print $1; }')
            KERNEL_MINOR_VERSION=$(echo "${KERNEL_VERSION}" | awk -F. '{ print $2; }')
            if [[ "$KERNEL_MAJOR_VERSION" -lt 4 ]] || [[ "$KERNEL_MAJOR_VERSION" -eq 4 && "$KERNEL_MINOR_VERSION" -lt 14 ]]; then
              echo "Linux kernel v4.14 or higher is required for Pixie, found ${KERNEL_MAJOR_VERSION}.${KERNEL_MINOR_VERSION}" >&2
              echo -e "\033[0;31mTurning off Pixie for this installation\033[0m" >&2
              PIXIE_SUPPORTED=false
            fi
          fi

          PIXIE_MEM="2Gi"
          # Check if the nodes have sufficient memory to install Pixie
          if [[ "$NR_CLI_PIXIE" == "true" && "$PIXIE_SUPPORTED" == "true" ]]; then
            MEMORY=$($SUDO $KUBECTL get nodes -o jsonpath='{.items[0].status.capacity.memory}' | sed 's/Ki$//')
            if [[ "$MEMORY" -lt 3906250 ]]; then
              echo "Pixie requires nodes with 4 Gb of memory or more, got ${MEMORY} Ki." >&2
              echo -e "\033[0;31mTurning off Pixie for this installation\033[0m" >&2
              PIXIE_SUPPORTED=false
            elif [[ "$MEMORY" -ge 3906250 ]] && [[ "$MEMORY" -lt 7812500 ]]; then
            	echo "Detected ${MEMORY} Ki.." >&2
              echo -e "\033[0;31mSetting Pixie memory limit to 1Gi.\033[0m" >&2
              PIXIE_MEM="1Gi"
              PIXIE_SUPPORTED=true
            elif [[ "$MEMORY" -ge 7812500 ]]; then
              echo "Detected ${MEMORY} Ki.." >&2
              echo -e "\033[0;31mSetting Pixie memory limit to 2Gi.\033[0m" >&2
              PIXIE_SUPPORTED=true
            fi
          fi

          # Check if the user has permissions to create a new namespace
          CAN_CREATE_NAMESPACE=$($SUDO $KUBECTL auth can-i create namespace 2>/dev/null)

          NAMESPACE_EXISTS=false
          if $SUDO $KUBECTL get namespace ${NR_CLI_NAMESPACE} 1>/dev/null 2>&1; then
            NAMESPACE_EXISTS=true
          fi

          if [[ "$NAMESPACE_EXISTS" != "true" && "$CAN_CREATE_NAMESPACE" != "yes" ]]; then
            echo "The ${NR_CLI_NAMESPACE} namespace does not exist and you don't have permissions to create a new namespace." >&2
            echo "Use an existing namespace or obtain permissions to create a new namespace." >&2
            echo "{\"Metadata\":{\"InstallationError\":\"${NR_CLI_NAMESPACE} Namespace does not exist and you don't have permissions to create a new namespace\", \"K8sClientVersion\":\"$CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\", \"K8sServerVersion\":\"$SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\"}}" | tee -a {{.NR_CLI_OUTPUT}}
            exit 1
          fi

          if [[ "$NR_CLI_PIXIE" == "true" && "$PIXIE_SUPPORTED" == "true" && "$CAN_CREATE_NAMESPACE" != "yes" ]]; then
            echo "Permissions to create a new namespace are required for Pixie." >&2
            echo -e "\033[0;31mTurning off Pixie for this installation\033[0m" >&2
            PIXIE_SUPPORTED=false
          fi

          # Check if the cluster type can support Pixie installation
          if [[ "$NR_CLI_PIXIE" == "true" && "$PIXIE_SUPPORTED" == "true" ]]; then
            PIXIE_SUPPORTED=false

            if [[ "$CLUSTER" == "docker-desktop" ]]; then
              echo "Docker for desktop is not supported. To create a test cluster to try out Pixie, use minikube instead." >&2
            fi

            if $SUDO which kind 1>/dev/null 2>&1; then
              if $SUDO kind get clusters 2>/dev/null | grep '^$(echo "'"${CLUSTER}"'" | sed -e "s/^kind-//g")$' >/dev/null; then
                echo "Kind is not supported. To create a test cluster to try out Pixie, use minikube instead." >&2
              fi
            fi

            MINIKUBE=$($SUDO which minikube 2>/dev/null || echo '/usr/local/bin/minikube')
            if [[ -x $MINIKUBE ]]; then
              if $SUDO $MINIKUBE profile list | grep " ${CLUSTER} " 1>/dev/null 2>&1; then
                DRIVER=$($SUDO $MINIKUBE profile list 2>/dev/null | grep " ${CLUSTER} " | awk -F"|" '{ gsub(" ", "", $3); print $3; }')
                if [[ "$DRIVER" == "kvm2" || "$DRIVER" == "hyperkit" ]] ; then
                  PIXIE_SUPPORTED=true
                else
                  echo "Unrecognized minikube driver. To create a test cluster to try out Pixie, use kvm2 or HyperKit instead." >&2
                fi
              fi
            fi

            if $SUDO which az 1>/dev/null 2>&1; then
              if $SUDO az aks list 2>/dev/null | grep '"name": "'"${CLUSTER}"'"' >/dev/null; then
                PIXIE_SUPPORTED=true
              fi
            fi

            # SHORT_FLAG_ERROR will be true if it returned an --short flag error earlier in the script
            # if SHORT_FLAG_ERROR is true, run KUBECTL version without --short flag since it was deprecated in kubectl version 1.28
            if $SHORT_FLAG_ERROR == true; then
              K8S_VERSION=$($SUDO $KUBECTL version | grep "Server Version")
            else
              K8S_VERSION=$($SUDO $KUBECTL version --short | grep "Server Version")
            fi

            if echo ${K8S_VERSION} | grep "\-gke\." >/dev/null; then
              PIXIE_SUPPORTED=true
            fi

            if echo ${K8S_VERSION} | grep "\-eks\-" >/dev/null; then
              PIXIE_SUPPORTED=true
            fi

            if echo ${K8S_VERSION} | grep "\+k[0,3]s.*" > /dev/null; then
              PIXIE_SUPPORTED=true
            fi

            if [[ "$PIXIE_SUPPORTED" != "true" ]]; then
              echo "This type of Kubernetes cluster is not supported by Pixie: GKE, EKS, AKS, Minikube, k3s, and k0s are supported." >&2
              echo -e "\033[0;31mTurning off Pixie for this installation\033[0m" >&2
              DEBUG_MESSAGE="Pixie is unsupported due to k8s version - ${K8S_VERSION}; ${DEBUG_MESSAGE}"
            fi

            if $SUDO $KUBECTL get namespace olm 1>/dev/null 2>&1; then
              OLM_INSTALLED=true
            fi
          fi

          # Create the namespace
          if ! $SUDO $KUBECTL get namespace ${NR_CLI_NAMESPACE} >/dev/null 2>&1; then
            $SUDO $KUBECTL create namespace ${NR_CLI_NAMESPACE}
          fi

          # Check if a privileged container can be deployed in the namespace
          if [[ "$NR_CLI_PRIVILEGED" == "true" ]]; then
          cat <<EOF > nr-check-privileged.yaml
          apiVersion: v1
          kind: Pod
          metadata:
            name: priv-check
          spec:
            hostNetwork: true
            dnsPolicy: ClusterFirstWithHostNet
            containers:
            - name: check
              image: newrelic/infrastructure-k8s
              securityContext:
                privileged: true
              command: ["/bin/sh"]
              args: ["-c", "sleep 60"]
          EOF

          if ! $SUDO $KUBECTL apply -n ${NR_CLI_NAMESPACE} -f nr-check-privileged.yaml >/dev/null; then
            echo "Failed to deploy a privileged container to the Kubernetes cluster." >&2
            echo -e "\033[0;31mReverting to unprivileged mode for this installation. Turning off Logging and Pixie.\033[0m" >&2
            NR_CLI_PRIVILEGED=false
            PIXIE_SUPPORTED=false
            NR_CLI_LOGGING=false
          fi
          $SUDO $KUBECTL delete --wait=false -n ${NR_CLI_NAMESPACE} -f nr-check-privileged.yaml 1>/dev/null 2>&1 || echo ""
          rm nr-check-privileged.yaml
          fi

          if [[ "$NR_CLI_NEWRELIC_PIXIE_INSTALLED" == "true" ]]; then
            if ! which px 1>/dev/null 2>&1 ; then
              echo "Pixie CLI not detected on cluster." >&2
              echo -e "\033[0;31mTurning off Pixie.\033[0m" >&2
              PIXIE_SUPPORTED=false
            else
              if ! NR_CLI_PIXIE_API_KEY=$(px api-key create -s -d 'New Relic integration' 2>&1 | tail -n 1); then
                echo "Failed to create Pixie API key using px CLI." >&2
                echo $NR_CLI_PIXIE_API_KEY >&2
                echo -e "\033[0;31mTurning off Pixie.\033[0m" >&2
                PIXIE_SUPPORTED=false
              fi
              if echo ${NR_CLI_PIXIE_API_KEY} | grep "px auth login" >/dev/null; then
                echo "Failed to create Pixie API key using px CLI." >&2
                echo $NR_CLI_PIXIE_API_KEY >&2
                echo -e "\033[0;31mTurning off Pixie.\033[0m" >&2
                PIXIE_SUPPORTED=false
              fi

              if ! NR_CLI_PIXIE_ENDPOINT=$(px get cluster --cloud-addr 2>&1 | tail -n 1); then
                echo "Failed to get Pixie cloud address using px CLI." >&2
                echo $NR_CLI_PIXIE_ENDPOINT >&2
                echo -e "\033[0;31mTurning off Pixie.\033[0m" >&2
                PIXIE_SUPPORTED=false
              fi
              if echo ${NR_CLI_PIXIE_ENDPOINT} | grep "px auth login" >/dev/null; then
                echo "Failed to get Pixie cloud address using px CLI." >&2
                echo $NR_CLI_PIXIE_ENDPOINT >&2
                echo -e "\033[0;31mTurning off Pixie.\033[0m" >&2
                PIXIE_SUPPORTED=false
              fi

              if ! NR_CLI_PIXIE_CLUSTER_ID=$(px get cluster --id 2>&1 | tail -n 1); then
                echo "Failed to get Pixie cluster id using px CLI." >&2
                echo $NR_CLI_PIXIE_CLUSTER_ID >&2
                echo -e "\033[0;31mTurning off Pixie.\033[0m" >&2
                PIXIE_SUPPORTED=false
              fi
              if echo ${NR_CLI_PIXIE_CLUSTER_ID} | grep "px auth login" >/dev/null; then
                echo "Failed to get Pixie cluster id using px CLI." >&2
                echo $NR_CLI_PIXIE_CLUSTER_ID >&2
                echo -e "\033[0;31mTurning off Pixie.\033[0m" >&2
                PIXIE_SUPPORTED=false
              fi
            fi
          fi

          # Check for the presence of Helm.
          # If Helm 3 is not found, revert to kubectl based install.
          if ! $SUDO which helm 1>/dev/null 2>&1
          then
                  echo ""
                  echo "Helm not found."
                  echo "Reverting to kubectl install."
                  echo ""

          elif ! $SUDO helm version -c --short | grep v3 1> /dev/null 2>&1
          then
                  echo ""
                  echo "Helm 3 not found.  You are using an unsupported version of helm."
                  echo "Reverting to kubectl install."
                  echo ""
          fi

          CLEANED_ARGS=""
          USED_HELM=false

          # Deploy the integration
          if $SUDO which helm 1>/dev/null 2>&1 && $SUDO helm version -c --short | grep v3 1> /dev/null 2>&1
          then
            USED_HELM=true
            echo ""
            echo "Using helm to install the Kubernetes integration"
            echo ""

            KUBECTL_INSTALL=false

            # Check if nri-bundle already installed, ask customer if they want uninstall before re-installation, and then move forward.
            GREEN='\033[0;32m'
            NC='\033[0m'
            if $SUDO helm list --all-namespaces | grep nri-bundle > /dev/null 2>&1; then
              echo "{\"Metadata\":{\"previousNriBundleDetected\":\"Yes\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}} > /dev/null
              while :; do
                echo -e -n "${GREEN}Detected a previously installed New Relic Kubernetes integration on cluster, uninstall first? (Uninstallation is recommended, default: Y) Y/N? ${NC} "
                if [[ "{{.NEW_RELIC_ASSUME_YES}}" == "true" ]]; then
                  UNINSTALL_ANSWER="Y"
                else
                  read ans
                  echo ""
                  UNINSTALL_ANSWER=$(echo "${ans^^}" | cut -c1-1)
                fi
                if [[ -z "$UNINSTALL_ANSWER" ]]; then
                  UNINSTALL_ANSWER="Y"
                fi
                if [[ "$UNINSTALL_ANSWER" == "N" ]]; then
                  echo "Attempting install over existing integration."
                  echo "{\"Metadata\":{\"uninstallNriBundleAnswer\":\"No\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}} > /dev/null
                  break
                fi
                if [[ "$UNINSTALL_ANSWER" == "Y" ]]; then
                  RELEASE_NAME=$(helm list --all-namespaces | grep nri-bundle | awk '{print $1}')
                  RELEASE_NAMESPACE=$(helm list --all-namespaces | grep nri-bundle | awk '{print $2}')
                  BUNDLE_VERSION=$(helm list --all-namespaces | grep nri-bundle | awk '{print $9}')
                  DEBUG_MESSAGE="nri-bundle version to uninstall - ${BUNDLE_VERSION}; ${DEBUG_MESSAGE}"
                  echo "{\"Metadata\":{\"uninstallNriBundleAnswer\":\"Yes\", \"helmUninstallCommand\":\"$SUDO helm uninstall $RELEASE_NAME -n $RELEASE_NAMESPACE\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}} > /dev/null
                  $SUDO helm uninstall $RELEASE_NAME -n $RELEASE_NAMESPACE
                  break
                fi
                echo -e "Please type Y or N only."
              done
            else
              echo "{\"Metadata\":{\"previousNriBundleDetected\":\"No\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}} > /dev/null
            fi

            HELM_VERSION="$($SUDO helm version -c --short)"
            # With 2>&1 >/dev/null, ERROR only keeps the error message if $? is non-zero and is empty if $? is zero
            ERROR=$($SUDO helm repo add newrelic https://helm-charts.newrelic.com 2>&1 >/dev/null)
            if [[ "${ERROR}" !=  "" ]]; then
              echo "helm (version $HELM_VERSION) repo add failed due to: $ERROR"
              exit 131
            fi

            if [[ $($SUDO helm repo update) ]] ; then
            else
              exit 131
            fi

            ARGS="--install newrelic-bundle newrelic/nri-bundle"
            ARGS="${ARGS} --set global.licenseKey=${NEW_RELIC_LICENSE_KEY}"
            ARGS="${ARGS} --set global.cluster=${NR_CLI_CLUSTERNAME}"
            ARGS="${ARGS} --namespace=${NR_CLI_NAMESPACE}"
            ARGS="${ARGS} --set newrelic-infrastructure.privileged=${NR_CLI_PRIVILEGED}"
            ARGS="${ARGS} --set global.lowDataMode=${NR_CLI_LOW_DATA_MODE}"
            if [[ "${NR_CLI_BETA}" == "true" ]]; then
              ARGS="${ARGS} --devel"
            fi
            ARGS="${ARGS} --set ksm.enabled=${NR_CLI_KSM}"

            # if installing in GKE Autopilot, we need to turn off controlPlane and pixie and set kubelet scheme and port
            if [[ "$GKE_AUTOPILOT_ANSWER" == "Y" ]]; then
              ARGS="${ARGS} --set newrelic-infrastructure.controlPlane.enabled=false"
              ARGS="${ARGS} --set newrelic-infrastructure.kubelet.config.scheme=http"
              ARGS="${ARGS} --set newrelic-infrastructure.kubelet.config.port=10255"
              ARGS="${ARGS} --set newrelic-pixie.enabled=false"
            fi

            # leaving this commented out for the future
            # if [[ $SERVER_MAJOR_VERSION -eq 1 && $SERVER_MINOR_VERSION -lt 25 ]]; then
            #   ARGS="${ARGS} --set kube-state-metrics.image.tag=v2.6.0"
            # else
            #   ARGS="${ARGS} --set kube-state-metrics.image.tag=v2.7.0"
            # fi

            ARGS="${ARGS} --set kube-state-metrics.image.tag=v2.10.0"

            # Prometheus integrations

            # Legacy Prometheus integration
            ARGS="${ARGS} --set prometheus.enabled=${NR_CLI_PROMETHEUS}"

            # Current Prometheus integration
            ARGS="${ARGS} --set newrelic-prometheus-agent.enabled=${NR_CLI_PROMETHEUS_AGENT}"
            ARGS="${ARGS} --set newrelic-prometheus-agent.lowDataMode=${NR_CLI_PROMETHEUS_AGENT_LOW_DATA_MODE}"
            ARGS="${ARGS} --set newrelic-prometheus-agent.config.kubernetes.integrations_filter.enabled=${NR_CLI_CURATED}"
            if [ -n "$NR_CLI_PROMETHEUS_CUSTOM_APP_LABELS" ]; then
              ARGS="${ARGS} --set newrelic-prometheus-agent.config.kubernetes.integrations_filter.app_values=\"${NR_CLI_PROMETHEUS_CUSTOM_APP_LABELS}\""
            fi

            ARGS="${ARGS} --set kubeEvents.enabled=${NR_CLI_KUBE_EVENTS}"
            ARGS="${ARGS} --set logging.enabled=${NR_CLI_LOGGING}"
            ARGS="${ARGS} --set newrelic-logging.lowDataMode=${NR_CLI_LOGGING_LOW_DATA_MODE}"
            if [[ -n "${NR_CLI_LOGGING_PERSISTENCE}" ]]; then
              ARGS="${ARGS} --set newrelic-logging.fluentBit.persistence.mode=${NR_CLI_LOGGING_PERSISTENCE}"
            fi
            if [[ -n "${NR_CLI_LOGGING_PERSISTENCE_STORAGE_CLASS}" ]]; then
              ARGS="${ARGS} --set newrelic-logging.fluentBit.persistence.persistentVolume.storageClass=${NR_CLI_LOGGING_PERSISTENCE_STORAGE_CLASS}"
            fi
            if [[ -n "${NR_CLI_LOGGING_LINUX_MOUNT_PATH}" ]]; then
              ARGS="${ARGS} --set newrelic-logging.fluentBit.linuxMountPath=${NR_CLI_LOGGING_LINUX_MOUNT_PATH}"
            fi
            
            if [[ "${NEW_RELIC_REGION}" == "STAGING" ]]; then
              ARGS="${ARGS} --set global.nrStaging=true"
            fi
            if [[ "${NR_CLI_NEWRELIC_PIXIE}" == "true" && "${PIXIE_SUPPORTED}" == "true" ]]; then
              ARGS="${ARGS} --set newrelic-pixie.enabled=true"
              ARGS="${ARGS} --set newrelic-pixie.apiKey=${NR_CLI_PIXIE_API_KEY}"
              if [[ "${NR_CLI_NEWRELIC_PIXIE_INSTALLED}" == "true" ]]; then
                ARGS="${ARGS} --set newrelic-pixie.endpoint=${NR_CLI_PIXIE_ENDPOINT}"
                ARGS="${ARGS} --set newrelic-pixie.clusterId=${NR_CLI_PIXIE_CLUSTER_ID}"
              elif [[ "${NR_CLI_PIXIE}" == "true" ]]; then
                ARGS="${ARGS} --set pixie-chart.enabled=true"
                ARGS="${ARGS} --set pixie-chart.deployKey=${NR_CLI_PIXIE_DEPLOY_KEY}"
                ARGS="${ARGS} --set pixie-chart.clusterName=${NR_CLI_CLUSTERNAME}"
                ARGS="${ARGS} --set pixie-chart.pemMemoryLimit=${PIXIE_MEM}"
                if [[ "${OLM_INSTALLED}" == "true" ]]; then
                  ARGS="${ARGS} --set pixie-chart.deployOLM=false"
                fi
                if [[ ! -z "${NR_CLI_PIXIE_ADDRESS}" ]]; then
                  ARGS="${ARGS} --set pixie-chart.cloudAddr=${NR_CLI_PIXIE_ADDRESS}"
                  ARGS="${ARGS} --set pixie-chart.cloudUpdateAddr=${NR_CLI_PIXIE_ADDRESS}"
                fi
              fi
            fi

            # Adding a quick test to ensure we don't expose any keys in case non-compatible versions of sed are used
            SEDTEST=$(echo 0 | sed -E 's/[a-zA-Z0-9\-]/1/')

            # Add helm upgrade command as metadata.  Keys are obfuscated.
            if [[ $SEDTEST -eq 1 ]]; then
              CLEANED_ARGS=$(echo $ARGS | sed -E 's/licenseKey=[a-zA-Z0-9\-]+/licenseKey=XXXXX/g' | sed -E 's/deployKey=[a-zA-Z0-9\-]+/deployKey=XXXXX/g' | sed -E 's/apiKey=[a-zA-Z0-9\-]+/apiKey=XXXXX/g')
            fi

            echo "{\"Metadata\":{\"helmVersion\":\"$($SUDO helm version -c --short)\", \"helmCommandBeforeExecution\":\"$SUDO helm upgrade $CLEANED_ARGS\", \"K8sClientVersion\":\"$CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\",\"K8sServerVersion\":\"$SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}} > /dev/null

            # With 2>&1 >/dev/null, ERROR only keeps the error message if $? is non-zero and is empty if $? is zero
            echo "Installing newrelic-bundle......."
            ERROR=$($SUDO helm upgrade $ARGS 2>&1 >/dev/null)
            if [[ "${ERROR}" != "" ]]; then
              if [[ "${GKE_AUTOPILOT_ANSWER}" == "Y" ]] && ! (echo "${ERROR}" | grep -q "Error"); then
                echo "Warnings from GKE Autopilot: $ERROR"
                break
              else
                echo "helm (version $HELM_VERSION) repo upgrade installation failed due to: $ERROR"
                exit 131
              fi
            fi
          else
            echo ""
            echo "Using kubectl to install the Kubernetes integration"
            echo ""

            KUBECTL_INSTALL=true

            # Select k8s-config-generator service environment
            if [[ "${NEW_RELIC_REGION}" == "STAGING" ]]; then
              URL="https://k8s-config-generator.staging-service.newrelic.com"
            else
              URL="https://k8s-config-generator.service.newrelic.com"
            fi

            if [[ "${NR_CLI_BETA}" == "true" ]]; then
              URL="${URL}/generate-beta"
            else
              URL="${URL}/generate"
            fi

            BODY="{\"global.cluster\":\"${NR_CLI_CLUSTERNAME}\""
            BODY="${BODY},\"global.namespace\":\"${NR_CLI_NAMESPACE}\""
            BODY="${BODY},\"newrelic-infrastructure.privileged\":\"${NR_CLI_PRIVILEGED}\""
            BODY="${BODY},\"global.lowDataMode\":\"${NR_CLI_LOW_DATA_MODE}\""
            BODY="${BODY},\"ksm.enabled\":\"${NR_CLI_KSM}\""

            # if installing in GKE Autopilot, turn off controlPlane and set kubelet scheme and port
            if [[ "$GKE_AUTOPILOT_ANSWER" == "Y" ]]; then
              BODY="${BODY},\"newrelic-infrastructure.controlPlane.enabled\":\"false\""
              BODY="${BODY},\"newrelic-infrastructure.kubelet.config.scheme\":\"http\""
              BODY="${BODY},\"newrelic-infrastructure.kubelet.config.port\":\"10255\""
            fi

            # leaving this commented out for the future
            # if [[ $SERVER_MAJOR_VERSION -eq 1 && $SERVER_MINOR_VERSION -lt 25 ]]; then
            #   BODY="${BODY},\"kube-state-metrics.image.tag\":\"v2.6.0\""
            # else
            #   BODY="${BODY},\"kube-state-metrics.image.tag\":\"v2.7.0\""
            # fi
            BODY="${BODY},\"kube-state-metrics.image.tag\":\"v2.10.0\""

            # Prometheus integrations

            # Legacy Prometheus integration
            BODY="${BODY},\"prometheus.enabled\":\"${NR_CLI_PROMETHEUS}\""

            # Current Prometheus integration
            BODY="${BODY},\"newrelic-prometheus-agent.enabled\":\"${NR_CLI_PROMETHEUS_AGENT}\""
            BODY="${BODY},\"newrelic-prometheus-agent.lowDataMode\":\"${NR_CLI_PROMETHEUS_AGENT_LOW_DATA_MODE}\""
            BODY="${BODY},\"newrelic-prometheus-agent.config.kubernetes.integrations_filter.enabled\":\"${NR_CLI_CURATED}\""
            if [ -n "$NR_CLI_PROMETHEUS_CUSTOM_APP_LABELS" ]; then
              BODY="${BODY},\"newrelic-prometheus-agent.config.kubernetes.integrations_filter.app_values\":\"${NR_CLI_PROMETHEUS_CUSTOM_APP_LABELS}\""
            fi

            BODY="${BODY},\"kubeEvents.enabled\":\"${NR_CLI_KUBE_EVENTS}\""
            BODY="${BODY},\"logging.enabled\":\"${NR_CLI_LOGGING}\""
            BODY="${BODY},\"newrelic-logging.lowDataMode\":\"${NR_CLI_LOGGING_LOW_DATA_MODE}\""
            BODY="${BODY},\"global.licenseKey\":\"${NEW_RELIC_LICENSE_KEY}\""
            if [[ "${NEW_RELIC_REGION}" == "STAGING" ]]; then
              BODY="${BODY},\"global.nrStaging\":true"
            fi

            if [[ "${NR_CLI_NEWRELIC_PIXIE}" == "true" && "${PIXIE_SUPPORTED}" == "true" ]]; then
              BODY="${BODY},\"newrelic-pixie.enabled\":true"
              BODY="${BODY},\"newrelic-pixie.apiKey\":\"${NR_CLI_PIXIE_API_KEY}\""
              if [[ "${NR_CLI_NEWRELIC_PIXIE_INSTALLED}" == "true" ]]; then
                BODY="${BODY},\"newrelic-pixie.endpoint\":\"${NR_CLI_PIXIE_ENDPOINT}\""
                BODY="${BODY},\"newrelic-pixie.clusterId\":\"${NR_CLI_PIXIE_CLUSTER_ID}\""
              elif [[ "${NR_CLI_PIXIE}" == "true" ]]; then
                BODY="${BODY},\"pixie-chart.enabled\":true"
                BODY="${BODY},\"pixie-chart.deployKey\":\"${NR_CLI_PIXIE_DEPLOY_KEY}\""
                BODY="${BODY},\"pixie-chart.clusterName\":\"${NR_CLI_CLUSTERNAME}\""
                BODY="${BODY},\"pixie-chart.pemMemoryLimit\":\"${PIXIE_MEM}\""
                if [[ "${OLM_INSTALLED}" == "true" ]]; then
                  BODY="${BODY},\"pixie-chart.deployOLM\":false"
                fi
                if [[ ! -z "${NR_CLI_PIXIE_ADDRESS}" ]]; then
                  BODY="${BODY},\"pixie-chart.cloudAddr\":\"${NR_CLI_PIXIE_ADDRESS}\""
                  BODY="${BODY},\"pixie-chart.cloudUpdateAddr\":\"${NR_CLI_PIXIE_ADDRESS}\""
                fi
              fi
            fi

            BODY="${BODY}}"
            $SUDO rm -f $KUBECTL_YAML_DIR/newrelic-k8s.yml
            curl -s -H "Content-Type: application/json" -d "${BODY}" "${URL}" > $KUBECTL_YAML_DIR/newrelic-k8s.yml

            if [[ "${NR_CLI_PIXIE}" == "true" ]]; then
              # only keep stderr in ERROR with 2>&1 >/dev/null; if the ERROR include any other than AlreadyExist, exit with the ERROR message
              ERROR=$($SUDO $KUBECTL create -f https://raw.githubusercontent.com/pixie-io/pixie/release/operator/v0.1.4/k8s/operator/helm/crds/olm_crd.yaml 2>&1 >/dev/null | grep -v AlreadyExists)
              if [[ "${ERROR}" != "" ]]; then
                echo "{\"Metadata\":{\"InstallationError\":\"OLM CRD creation failed - ${ERROR}\", \"K8sClientVersion\":\"$CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\", \"K8sServerVersion\":\"$SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}}
                exit 33
              fi
              ERROR=$($SUDO $KUBECTL create -f https://raw.githubusercontent.com/pixie-io/pixie/release/operator/v0.1.4/k8s/operator/crd/base/px.dev_viziers.yaml 2>&1 >/dev/null | grep -v AlreadyExists)
              if [[ "${ERROR}" != "" ]]; then
                echo "{\"Metadata\":{\"InstallationError\":\"PX DEV VIZIERS creation failed - ${ERROR}\", \"K8sClientVersion\":\"$CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\", \"K8sServerVersion\":\"$SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}}
                exit 33
              fi
            fi

            # Clean up old nri-metadata-injection jobs if they exist
            if [[ $($SUDO $KUBECTL get jobs -n ${NR_CLI_NAMESPACE} --no-headers 2> /dev/null | grep metadata-injection-admission | wc -l | xargs) -gt 0 ]]; then
              echo "Cleaning up old nri-metadata-injection jobs..."
              for j in $($SUDO $KUBECTL get jobs -n ${NR_CLI_NAMESPACE} --no-headers 2> /dev/null | grep metadata-injection-admission | awk '{print $1}')
              do
                $SUDO $KUBECTL delete job $j -n ${NR_CLI_NAMESPACE}
              done
            fi

            if [[ $($SUDO $KUBECTL apply -f $KUBECTL_YAML_DIR/newrelic-k8s.yml) ]]; then
            else
              exit 131
            fi
          fi

          HELM_COMMAND="helm not used"
          HELM_VERSION="helm not used"

          if $USED_HELM
          then
            HELM_COMMAND="$SUDO helm upgrade $CLEANED_ARGS"
            HELM_VERSION="$($SUDO helm version -c --short)"
          fi

          # Check for 'nrk8s-kubelet-node-scraper' pod presence first, otherwise default to former pod name 'nrk8s-kubelet'
          POD_NAME=$(test $($SUDO $KUBECTL get pods -o wide -n $NR_CLI_NAMESPACE | grep 'nrk8s-kubelet-node-scraper' | wc -l | sed 's/ //g') -gt 0 && echo 'nrk8s-kubelet-node-scraper' || echo 'nrk8s-kubelet')

          echo "Running ${POD_NAME} status check attempt..."
          MAX_RETRIES=150
          TRIES=0
          while [ $TRIES -lt $MAX_RETRIES ]; do
            ((TRIES++))
            IS_INFRA_POD_STARTED=$($SUDO $KUBECTL get pods -o wide -n $NR_CLI_NAMESPACE | grep ${POD_NAME} | grep -i "running" | wc -l | sed 's/ //g')
            if [[ $IS_INFRA_POD_STARTED -gt 0 ]]; then
              echo "${POD_NAME} pod started"
              break
            fi
            if [ "$TRIES" -eq "$MAX_RETRIES" ]; then
              echo "${POD_NAME} pod is not starting" >&2
              BUNDLE_VERSION=$(helm list --all-namespaces | grep nri-bundle | awk '{print $9}')
              DEBUG_MESSAGE="nri-bundle version - ${BUNDLE_VERSION}; ${DEBUG_MESSAGE}"
              POD_STATUS=$($SUDO $KUBECTL get pods -o wide -n $NR_CLI_NAMESPACE | grep ${POD_NAME} | awk '{print $3}')
              POD_RESTARTS=$($SUDO $KUBECTL get pods -o wide -n $NR_CLI_NAMESPACE | grep ${POD_NAME} | awk '{print $4}')
              DEBUG_MESSAGE="${POD_NAME} status - ${POD_STATUS}; ${POD_NAME} restarts - ${POD_RESTARTS}; ${DEBUG_MESSAGE}"
              echo "{\"Metadata\":{\"InstallationError\":\"${POD_NAME} pod is not starting\", \"K8sClientVersion\":\"$CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\", \"K8sServerVersion\":\"$SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}}
              exit 33
            fi
            sleep 2
          done

          echo "{\"Metadata\":{\"helmVersion\":\"$HELM_VERSION\", \"helmCommand\":\"$HELM_COMMAND\", \"K8sClientVersion\":\"$CLIENT_MAJOR_VERSION.$CLIENT_MINOR_VERSION\",\"K8sServerVersion\":\"$SERVER_MAJOR_VERSION.$SERVER_MINOR_VERSION\",\"DebugMessage\":\"$DEBUG_MESSAGE\"}}" | tee -a {{.NR_CLI_OUTPUT}}

          # Set the color variables for post install message
          green='\033[0;32m'
          clear='\033[0m'

          # Show post install message
          echo ""
          echo "--------------------------"
          echo ""

          if $KUBECTL_INSTALL; then
            printf "** Store the generated ${green}$KUBECTL_YAML_DIR/newrelic-k8s.yml${clear} file in a safe location in order to upgrade or remove the integration. **\n"
          fi

          echo ""
          echo "You can check the status of the New Relic pods by running:"
          echo ""
          printf "     ${green}kubectl get pods -o wide -n ${NR_CLI_NAMESPACE}${clear}\n"
          echo ""
          echo "--------------------------"
          echo ""
